<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spark(2): 对比各种join姿势</title>
      <link href="/2022/02/15/spark-2-%E8%AF%B4%E9%80%8FSQL-join/"/>
      <url>/2022/02/15/spark-2-%E8%AF%B4%E9%80%8FSQL-join/</url>
      
        <content type="html"><![CDATA[<p>众所周知,Join的种类丰富:</p><p>按照**关联形式(**Join type)划分:</p><p>有内关联,外关联,左关联,右关联,半关联,逆关联等,由业务逻辑决定的关联形式决定了Spark任务的运行结果;</p><p>按照<strong>关联机制</strong>(Join Mechanisms)划分:</p><p>有NLJ(Nested Loop Join) , SMJ(Sort Merge Join)和HJ(Hash Join),由数据内容决定的实现机制,则决定了Spark任务的运行效率;</p><h2 id="关联形式"><a href="#关联形式" class="headerlink" title="关联形式"></a>关联形式</h2><p>Spark支持的关联形式:</p><table><thead><tr><th>关联形式</th><th>Join Type关键字</th></tr></thead><tbody><tr><td>内连接</td><td>inner</td></tr><tr><td>左外关联</td><td>left / left outer / left_outer</td></tr><tr><td>右外关联</td><td>right/ right outer/right_outer</td></tr><tr><td>全外关联</td><td>outer/ full / full outer / full_outer</td></tr><tr><td>左半关联</td><td>left semi/ left_semi</td></tr><tr><td>左逆关联</td><td>left anti / left_anti</td></tr><tr><td>交叉关联</td><td>crossJoin</td></tr></tbody></table><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">DataFrame</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建员工信息表</span></span><br><span class="line"><span class="keyword">val</span> seq = <span class="type">Seq</span>((<span class="number">1</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">28</span>, <span class="string">&quot;Male&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;Lily&quot;</span>, <span class="number">30</span>, <span class="string">&quot;Female&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;Raymond&quot;</span>, <span class="number">26</span>, <span class="string">&quot;Male&quot;</span>), (<span class="number">5</span>, <span class="string">&quot;Dave&quot;</span>, <span class="number">36</span>, <span class="string">&quot;Male&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> employees: <span class="type">DataFrame</span> = seq.toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建薪资表</span></span><br><span class="line"><span class="keyword">val</span> seq2 = <span class="type">Seq</span>((<span class="number">1</span>, <span class="number">26000</span>), (<span class="number">2</span>, <span class="number">30000</span>), (<span class="number">4</span>, <span class="number">25000</span>), (<span class="number">3</span>, <span class="number">20000</span>))</span><br><span class="line"><span class="keyword">val</span> salaries:<span class="type">DataFrame</span> = seq2.toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;salary&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左表</span></span><br><span class="line">salaries.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| id|salary|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| 1| 26000|</span></span><br><span class="line"><span class="comment">| 2| 30000|</span></span><br><span class="line"><span class="comment">| 4| 25000|</span></span><br><span class="line"><span class="comment">| 3| 20000|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 右表</span></span><br><span class="line">employees.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+-------+---+------+</span></span><br><span class="line"><span class="comment">| id| name|age|gender|</span></span><br><span class="line"><span class="comment">+---+-------+---+------+</span></span><br><span class="line"><span class="comment">| 1| Mike| 28| Male|</span></span><br><span class="line"><span class="comment">| 2| Lily| 30|Female|</span></span><br><span class="line"><span class="comment">| 3|Raymond| 26| Male|</span></span><br><span class="line"><span class="comment">| 5| Dave| 36| Male|</span></span><br><span class="line"><span class="comment">+---+-------+---+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="内连接-Inner-join"><a href="#内连接-Inner-join" class="headerlink" title="内连接(Inner join)"></a>内连接(Inner join)</h4><p>内连接是默认关联形式,可以省略写成join. 左右表按照join key连接, <code>舍弃未匹配的行,仅仅保留左右表中满足关联条件的那些数据记录</code>.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内关联</span></span><br><span class="line"><span class="keyword">val</span> jointDF: <span class="type">DataFrame</span> = salaries.join(employees, salaries(<span class="string">&quot;id&quot;</span>) === employees(<span class="string">&quot;id&quot;</span>), <span class="string">&quot;inner&quot;</span>)</span><br><span class="line"> </span><br><span class="line">jointDF.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+------+---+-------+---+------+</span></span><br><span class="line"><span class="comment">| id|salary| id| name|age|gender|</span></span><br><span class="line"><span class="comment">+---+------+---+-------+---+------+</span></span><br><span class="line"><span class="comment">| 1| 26000| 1| Mike| 28| Male|</span></span><br><span class="line"><span class="comment">| 2| 30000| 2| Lily| 30|Female|</span></span><br><span class="line"><span class="comment">| 3| 20000| 3|Raymond| 26| Male|</span></span><br><span class="line"><span class="comment">+---+------+---+-------+---+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="外连接-Outer-join"><a href="#外连接-Outer-join" class="headerlink" title="外连接(Outer join)"></a>外连接(Outer join)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jointDF: <span class="type">DataFrame</span> = salaries.join(employees, salaries(<span class="string">&quot;id&quot;</span>) === employees(<span class="string">&quot;id&quot;</span>), <span class="string">&quot;left&quot;</span>)</span><br><span class="line"> </span><br><span class="line">jointDF.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+------+----+-------+----+------+</span></span><br><span class="line"><span class="comment">| id|salary| id| name| age|gender|</span></span><br><span class="line"><span class="comment">+---+------+----+-------+----+------+</span></span><br><span class="line"><span class="comment">| 1| 26000| 1| Mike| 28| Male|</span></span><br><span class="line"><span class="comment">| 2| 30000| 2| Lily| 30|Female|</span></span><br><span class="line"><span class="comment">| 4| 25000|null| null|null| null|</span></span><br><span class="line"><span class="comment">| 3| 20000| 3|Raymond| 26| Male|</span></span><br><span class="line"><span class="comment">+---+------+----+-------+----+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>外连接的左右指的是不满足join条件的数据来自于哪张表,上述的”left”左外连接,就让第三行数据来自于左表.</p><h4 id="半关联-semi-join"><a href="#半关联-semi-join" class="headerlink" title="半关联(semi join)"></a>半关联(semi join)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 左半关联</span></span><br><span class="line"><span class="keyword">val</span> jointDF: <span class="type">DataFrame</span> = salaries.join(employees, salaries(<span class="string">&quot;id&quot;</span>) === employees(<span class="string">&quot;id&quot;</span>), <span class="string">&quot;leftsemi&quot;</span>)</span><br><span class="line"> </span><br><span class="line">jointDF.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| id|salary|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| 1| 26000|</span></span><br><span class="line"><span class="comment">| 2| 30000|</span></span><br><span class="line"><span class="comment">| 3| 20000|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>半关联是inner join的一半返回,left semi join返回左表数据, right semi join返回右表数据</p><h4 id="逆关联-anti-join"><a href="#逆关联-anti-join" class="headerlink" title="逆关联(anti join)"></a>逆关联(anti join)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 左逆关联</span></span><br><span class="line"><span class="keyword">val</span> jointDF: <span class="type">DataFrame</span> = salaries.join(employees, salaries(<span class="string">&quot;id&quot;</span>) === employees(<span class="string">&quot;id&quot;</span>), <span class="string">&quot;leftanti&quot;</span>)</span><br><span class="line"> </span><br><span class="line">jointDF.show</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 结果打印</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| id|salary|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">| 4| 25000|</span></span><br><span class="line"><span class="comment">+---+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>逆关联返回的是未关联上的行.</p><h2 id="关联机制"><a href="#关联机制" class="headerlink" title="关联机制"></a>关联机制</h2><h3 id="spark的关联机制"><a href="#spark的关联机制" class="headerlink" title="spark的关联机制"></a>spark的关联机制</h3><table><thead><tr><th>join实现机制</th><th>工作原理</th><th>适用场景</th></tr></thead><tbody><tr><td>Nested Loop Join</td><td>在驱动表与基表之上,使用嵌套的双层for循环实现关联,效率最低,算法复杂度为O(M*N)</td><td>其他策略不使用的情况</td></tr><tr><td>Sort Merge Join</td><td>首先将两张表排序,然后以双指针遍历的方式实现关联,关联阶段的算法复杂度为O(M+N)</td><td>两张表都按照join key排序的情况</td></tr><tr><td>Hash Join</td><td>关联过程分为两个阶段 Build + Probe , Build 使用Hash算法生成哈希表O(N),Probe 查表获得值O(M)</td><td>哈希表较小且易生成.</td></tr></tbody></table><h2 id="关联策略"><a href="#关联策略" class="headerlink" title="关联策略"></a>关联策略</h2><h3 id="Spark的关联策略对比"><a href="#Spark的关联策略对比" class="headerlink" title="Spark的关联策略对比"></a>Spark的关联策略对比</h3><table><thead><tr><th>对比项</th><th>Shuffle Join</th><th>Broadcast Join</th></tr></thead><tbody><tr><td>实现原理</td><td>* 根据Join Keys 计算哈希值<br />* 将哈希值按照并行度(parallelism)取模</td><td>封装一张小表为广播变量,发送到所有Executor.</td></tr><tr><td>优点</td><td>不论数据的体量是大是小、不管内存是否足够，Shuffle Join 在功能上都能成功地完成数据关联的计算</td><td>通过分发较小数据表,SQL的执行性能高效.</td></tr><tr><td>适用场景</td><td>任何场景都能完成</td><td>广播表较小</td></tr><tr><td>前提条件</td><td>无</td><td>基表需要足够小(小于Excutor内存)</td></tr><tr><td>缺点</td><td>shuffle IO 带来的性能瓶颈</td><td>无</td></tr></tbody></table><h2 id="关联机制-x-关联策略"><a href="#关联机制-x-关联策略" class="headerlink" title="关联机制 x 关联策略"></a>关联机制 x 关联策略</h2><p>3种关联机制跟 2中关联策略的组合,出现了6中join.由于Broadcast SMJ &lt; Broadcast HJ ,去掉毫无用武之处的Broadcast SMJ,余下了以下5种join方式.</p><table><thead><tr><th>join方式</th><th>原理</th><th>适用场景</th></tr></thead><tbody><tr><td>Broadcast HJ</td><td>基表加工成哈希表,广播到所有Executor,内部查表连接</td><td>基表小,等值join查表快</td></tr><tr><td>Broadcast NLJ</td><td>广播小表,Excutor内部用双重循环连接</td><td>基表小,可以用于不等值join</td></tr><tr><td>Shuffle SMJ</td><td>因为Shuffle要按照join key排序,所以spark 优先选择SMJ</td><td>基表大</td></tr><tr><td>Shuffle HJ</td><td>因为SMJ的原因,Shuffle HJ基本不用</td><td>同Shuffle SMJ</td></tr><tr><td>Shuffle NLJ</td><td>两张表都比较大,而且join是非等值join</td><td>其他场景都不适用的情况</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper --大数据的管理员</title>
      <link href="/2021/12/29/zookeeper-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%A1%E7%90%86%E5%91%98/"/>
      <url>/2021/12/29/zookeeper-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%A1%E7%90%86%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZooKeeper在HBase系统中扮演着非常重要的角色。事实上，无论在HBase中，还是在Hadoop其他的分布式项目中，抑或是非Hadoop生态圈的很多开源项目中，甚至是全球大大小小的公司内，ZooKeeper都是一项非常重要的基础设施。ZooKeeper之所以占据如此重要的地位，是因为它解决了分布式系统中一些最基础的问题：</p><ul><li>提供极低延迟、超高可用的内存KV数据库服务。</li><li>提供中心化的服务故障发现服务。</li><li>提供分布式场景下的锁、Counter、Queue等协调服务。</li></ul><p>ZooKeeper集群本身是一个服务高可用的集群，通常由奇数个（比如3个、5个等）节点组成，集群的服务不会因小于一半的节点宕机而受影响。ZooKeeper集群中多个节点都存储同一份数据，为保证多节点之间数据的一致性，ZooKeeper使用ZAB（ZooKeeper Atomic Broadcast）协议作为数据一致性的算法。ZAB是由Paxos算法改进而来，论文《 Zab: High-performance broadcast for primary-backup systems 》。</p><p>ZooKeeper节点内数据组织为树状结构，如下图所示，数据存储在每一个树节点（称为znode）上，用户可以根据数据路径获取对应的数据。</p><img src="https://s2.loli.net/2021/12/29/jBrAcXuU1vp7OZF.png" alt="image-20211229180824274" style="zoom:33%;" /><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka 异常知其所以然</title>
      <link href="/2021/12/24/kafka-%E5%BC%82%E5%B8%B8%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/"/>
      <url>/2021/12/24/kafka-%E5%BC%82%E5%B8%B8%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-kafka-Producer内存不足"><a href="#1-kafka-Producer内存不足" class="headerlink" title="1. kafka Producer内存不足"></a>1. kafka Producer内存不足</h3><img src="https://i.loli.net/2021/09/26/FImGQW3ZArDV9ak.png" alt="image-20210926163136079" style="zoom:50%;" /><p>生产者客户端由两个线程协调运行：主线程和Sender线程（发送线程）；</p><p>主线程由KafkaProducer创建消息，通过拦截器序列化器跟分区器之后<strong>缓存</strong>到消息累加器（RecordAccumulator），然后通过Sender线程批量发送。这个缓存大小由生产者客户端buffer.memory配置，默认值为32MB，一次发送的间隔时间由max.block.ms配置，此参数的默认值为60000ms，即60s。</p><p>在上述两个配置均为默认配置的时候，如果<strong>发送端的消息每分钟大小超过32MB</strong>，这个时候KafkaProducer的send()方法要么被阻塞，要么抛出异常。</p><h3 id="2-kafka数据丢失的几种可能"><a href="#2-kafka数据丢失的几种可能" class="headerlink" title="2.  kafka数据丢失的几种可能"></a>2.  kafka数据丢失的几种可能</h3><p><strong>1）生产者没有指定重试次数（默认的重试次数是0），发生了一些可重试的Exception</strong>。</p><p>常见的可重试Exception包括：</p><ul><li><p>NetworkException： 表示网络异常，有可能是瞬时的网络故障，重试可以恢复；</p></li><li><p>LeaderNotAvaliableException： leader副本不可用，有可能老的leader副本下线，新的leader副本正在选举，也是重试可恢复的。</p></li><li><p>UnknownTopicOrPartitionException： 虽然topic和分区是会自动创建的，创建分区不是一个瞬时的操作，这个过程是需要一定时间的，在此期间内发送的Record有可能会抛出此异常，该异常同样可以通过retry解决。</p></li><li><p>NotEnoughReplicasException： 因为min.insync.replicas&gt;可用的replica数，这个异常也可以重试，直到Replica Map中有可用的副本接受消息并返回。</p></li><li><p>NotCoordinatorException:  收到的事务ID与协调器不一致的时候会抛出此异常。</p></li><li><p>TimeoutException：Request timeout的时候会抛出此异常，参数是<code>request.timeout.ms</code>，注意这个参数需要比服务器端的request.timeout.ms要大，这样可以减少因为重试造成的消息重复。</p></li></ul><p>Producer端的重试参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prop.put(ProducerConfig.RETRIES_CONFIG, <span class="number">10</span>); <span class="comment">//重试10次</span></span><br><span class="line">prop.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, Duration.ofMinutes(<span class="number">3</span>).toMillis()); <span class="comment">//3min重试一次，默认为60s</span></span><br></pre></td></tr></table></figure><p><strong>2） acks配置不正确</strong></p><p>acks是用来指定kafka中必须有多少个副本收到这条消息，生产者才会认为这条消息成功写入,它涉及到权衡吞吐性跟可靠性,一般来说acks的值越大,可靠性越大,但是吞吐性能会随之降低.(因为acks中可选all，所以该参数配置的时候用字符串类型)</p><ul><li>acks = 1（默认）：</li></ul><p>生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息无法写入leader副本，比如在leader 副本崩溃、重新选举新的leader 副本的过程中，那么生产者就会收到一个错误的响应，如果没有重试机制,在写入下一个leaader副本时失败了就会缺数据.(前面回复ack的leader副本在后面一次选举中没有当选leader)</p><ul><li>acks=0 </li></ul><p>我发我的,不管你收没收到,因为没法得知服务器的响应,如果在写入过程中出现了什么异常,消息就丢失了.</p><ul><li>acks=-1 或 acks=all</li></ul><p>这个是最强可靠性的保证,所有replica收到ack才算写入成功.</p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase 基础</title>
      <link href="/2021/12/23/Hbase-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/23/Hbase-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Hbase是什么"><a href="#Hbase是什么" class="headerlink" title="Hbase是什么"></a>Hbase是什么</h2><p>非常热门的一款KV数据库系统,<strong>高可靠,易扩展,高性能,社区支持.</strong></p><p>发展史可以参考下面 的版本图:</p><p><img src="https://s2.loli.net/2021/12/23/YzLfnhrIUZJaykF.png" alt="image-20211223153057998"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><ul><li><p>table: 表,一个表可以包含多行</p></li><li><p>row: 行,一行包含唯一的rowkey和多个列簇,列可动态扩展,所有row按照rowkey的字段序从小到大排列.</p></li><li><p>column: 列，与关系型数据库中的列不同，HBase中的column由column family（列簇）以及qualifier（列名）两部分组成，两者中间使用”:”相连。比如contents:html，其中contents为列簇，html为列簇下具体的一列。column family在表创建的时候需要指定，用户不能随意增减。一个column family下可以设置任意多个qualif ier，因此可以理解为HBase中的列可以动态增加，理论上甚至可以扩展到上百万列。</p></li><li><p>timestamp: 时间戳，每个cell在写入HBase的时候都会默认分配一个时间戳作为该cell的版本，当然，用户也可以在写入的时候自带时间戳。HBase支持多版本特性，即同一rowkey、column下可以有多个value存在，这些value使用timestamp作为版本号，版本越大，表示数据越新。</p></li><li><p>cell: 单元格，由五元组（row, column, timestamp, type, value）组成的结构，其中type表示Put/Delete这样的操作类型，timestamp代表这个cell的版本。这个结构在数据库中实际是以KV结构存储的，其中（row, column, timestamp, type）是K,对应KV结构的V。</p></li></ul><blockquote><p>Hbase的存储如下</p><p>{(rowkey,column family, qualifier, type, tms) -&gt; “value”}</p></blockquote><h3 id="存储结构特性"><a href="#存储结构特性" class="headerlink" title="存储结构特性"></a>存储结构特性</h3><p>基于Hbase的存储形式,Hbase有以下特性,</p><ul><li><p>多维: Hbase跟普通map不同,他的key是一个多维的复合结构.</p></li><li><p>稀疏: 无论是行存还是列存,在某个属性不存在的时候会填充null,在扩展的时候会造成大量空间浪费.</p></li><li><p>排序: 构成HBase的KV在同一个文件中都是有序的，但规则并不是仅仅按照rowkey排序，而是按照KV中的key进行排序——先比较rowkey，rowkey小的排在前面；如果rowkey相同，再比较column，即column family:qualifier，column小的排在前面；如果column还相同，再比较时间戳timestamp，即版本信息，timestamp大的排在前面</p></li><li><p>更新: 基于map的特性,新的值会自动覆盖旧的值,天然支持更新.</p></li><li><p>分布式: Hbase的所有map分布式存储.</p></li></ul><h3 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h3><p>Hbase的架构如下:</p><p>​    </p><p><img src="https://s2.loli.net/2021/12/23/n6W1BVPtpDxUaMA.png" alt="image-20211223154806093"></p><h4 id="Hbase客户端"><a href="#Hbase客户端" class="headerlink" title="Hbase客户端"></a>Hbase客户端</h4><p>提供了hbase-shell接口,原生的JavaAPI, Thrift/REST API,以及MapReduce接口.HBase客户端支持所有常见的DML操作以及DDL操作，即数据的增删改查和表的日常维护等。其中Thrift/REST API主要用于支持非Java的上层业务需求，MapReduce接口主要用于批量数据导入以及批量数据读取。</p><p>HBase客户端访问数据行之前，首先需要通过元数据表定位目标数据所在RegionServer，之后才会发送请求到该RegionServer。同时这些元数据会被缓存在客户端本地，以方便之后的请求访问。如果集群RegionServer发生宕机或者执行了负载均衡等，从而导致数据分片发生迁移，客户端需要重新请求最新的元数据并缓存在本地。</p><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><p>分布式协调管理组件,在分布式系统中很常见,在其他大数据组件如Kafka等都有用到,在Hbase中的作用主要是:</p><ul><li><p>实现Master高可用: 检测Master的状态,宕机时选举新的Master</p></li><li><p>管理系统核心元数据: 比如，管理当前系统中正常工作的RegionServer集合，保存系统元数据表hbase:meta所在的RegionServer地址等</p></li><li><p>参与RegionServer宕机恢复: 比如，管理当前系统中正常工作的RegionServer集合，保存系统元数据表hbase:meta所在的RegionServer地址等</p></li><li><p>实现分布式表锁：HBase中对一张表进行各种管理操作（比如alter操作）需要先加表锁，防止其他用户对同一张表进行管理操作，造成表状态不一致。和其他RDBMS表不同，HBase中的表通常都是分布式存储，ZooKeeper可以通过特定机制实现分布式表锁。</p></li></ul><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>负责Hbase的各种管理工作:</p><ul><li>处理用户请求如建表,修改表,权限操作,切分表合并数据分片以及Compaction等</li><li>管理RegionServer,包括负载均衡和宕机恢复以及Region迁移</li><li>清理过期日志和文件. 周期性检查和清理已过期和被删除的日志文件.</li></ul><h4 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h4><p>主要是相应IO请求.主要由<code>WAL(HLog)</code>,<code>BlockCache</code>和多个<code>Region</code>组成</p><ul><li><p>WAL(HLog):  保障异步写入的中间文件</p><blockquote><p> 1.实现高可靠性: HBase数据随机写入时，并非直接写入HFile数据文件，而是先写入缓存，再异步刷新落盘。为了防止缓存数据丢失，数据写入缓存之前需要首先顺序写入HLog，这样，即使缓存数据丢失，仍然可以通过HLog日志恢复</p><ol start="2"><li>用于Hbase集群之间的主从复制: 通过回放主集群推送过来的HLog日志实现主从复制</li></ol></blockquote></li><li><p>BlockCache: 读缓存块</p><p> HBase系统中的读缓存。客户端从磁盘读取数据之后通常会将数据缓存到系统内存中，后续访问同一行数据可以直接从内存中获取而不需要访问磁盘,减少IO次数. BlockCache是一系列Block块,默认每个块64K,是物理相邻的多个KV数据组. 当前BlockCache主要有两种实现——LRUBlockCache和BucketCache，前者实现相对简单，而后者在GC优化方面有明显的提升。</p></li><li><p>Region: 数据分片,数据表的一个分片，当数据表大小超过一定阈值就会“水平切分”，分裂为两个Region。Region是集群负载均衡的基本单位。通常一张表的Region会分布在整个集群的多台RegionServer上，一个RegionServer上会管理多个Region，当然，这些Region一般来自不同的数据表。</p></li></ul><p>一个Region由一个或者多个Store构成，Store的个数取决于表中列簇（column family）的个数，多少个列簇就有多少个Store。HBase中，每个列簇的数据都集中存放在一起形成一个存储单元Store，因此建议将具有相同IO特性的数据设置在同一个列簇中。每个Store由一个MemStore和一个或多个HFile组成。MemStore称为写缓存，用户写入数据时首先会写到MemStore，当MemStore写满之后（缓存数据超过阈值，默认128M）系统会异步地将数据flush成一个HFile文件。显然，随着数据不断写入，HFile文件会越来越多，当HFile文件数超过一定阈值之后系统将会执行Compact操作，将这些小文件通过一定策略合并成一个或多个大文件。</p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>Hbase的底层存储,包括用户数据文件,Hlog日志等都会落盘HDFS.</p><h3 id="系统特性"><a href="#系统特性" class="headerlink" title="系统特性"></a>系统特性</h3><h4 id="优点-pick-point"><a href="#优点-pick-point" class="headerlink" title="优点/pick point"></a>优点/pick point</h4><ul><li><p>容量巨大: 千亿行百万列,数据量可以到TB甚至PB.</p></li><li><p>高可扩展: 存储不够可以增加DataNode来增加HDFS容量,读写服务不佳可以增加RegionServer增加计算能力.</p></li><li><p>稀疏性: 允许大量列值为空,而且null不占空间,对加列场景尤其适合.</p></li><li><p>高性能: 擅长OTLP场景,读写快.尤其是单点取值.</p></li><li><p>支持历史版本: 同一个key可以根据tms保存多个版本.</p></li><li><p>支持过期: 与很多KV数据库一样,Hbase也支持在写入时指定TTL,无需写程序手动删除,</p></li><li><p>Hadoop原生支持.意味着可以绕过hbase直接操作hfile,高效操作和导入导出.</p></li></ul><h4 id="缺点-ban-point"><a href="#缺点-ban-point" class="headerlink" title="缺点/ban point"></a>缺点/ban point</h4><ul><li>不支持复杂的聚合运算: join和group by都不支持,需要搭配其他组件,入spark或者Phoenix.</li><li>不支持二级索引: 本身没有二级索引功能,不过可以搭配Phoenix提供二级索引</li><li>不支持全局跨行事务,只支持单行事务,Phoenix同样也能实现全局事务模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive(2): UDAF 和 UDTF</title>
      <link href="/2021/12/21/hive-UDF%E5%87%BD%E6%95%B0/"/>
      <url>/2021/12/21/hive-UDF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="UDAF"><a href="#UDAF" class="headerlink" title="UDAF"></a>UDAF</h2><p>UDAF 又称聚合函数,将分组内的多行结果汇总到一行.一般情况下跟着group by一起出现,没有group by的时候认为全表为一组.</p><p>为了看起来有效果,先准备一下数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_scores(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">studentId <span class="type">int</span>,</span><br><span class="line"><span class="keyword">language</span> <span class="type">int</span>,</span><br><span class="line">math <span class="type">int</span>,</span><br><span class="line">english <span class="type">int</span>,</span><br><span class="line">classId string,</span><br><span class="line">departmentId string</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 写入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> student_scores <span class="keyword">values</span> </span><br><span class="line">  (<span class="number">1</span>,<span class="number">111</span>,<span class="number">68</span>,<span class="number">69</span>,<span class="number">90</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">2</span>,<span class="number">112</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">96</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">3</span>,<span class="number">113</span>,<span class="number">90</span>,<span class="number">74</span>,<span class="number">75</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">4</span>,<span class="number">114</span>,<span class="number">89</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">5</span>,<span class="number">115</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">89</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">6</span>,<span class="number">121</span>,<span class="number">96</span>,<span class="number">74</span>,<span class="number">79</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">7</span>,<span class="number">122</span>,<span class="number">89</span>,<span class="number">86</span>,<span class="number">85</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">8</span>,<span class="number">123</span>,<span class="number">70</span>,<span class="number">78</span>,<span class="number">61</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">9</span>,<span class="number">124</span>,<span class="number">76</span>,<span class="number">70</span>,<span class="number">76</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department1&#x27;</span>),</span><br><span class="line">  (<span class="number">10</span>,<span class="number">211</span>,<span class="number">89</span>,<span class="number">93</span>,<span class="number">60</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">11</span>,<span class="number">212</span>,<span class="number">76</span>,<span class="number">83</span>,<span class="number">75</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">12</span>,<span class="number">213</span>,<span class="number">71</span>,<span class="number">94</span>,<span class="number">90</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">13</span>,<span class="number">214</span>,<span class="number">94</span>,<span class="number">94</span>,<span class="number">66</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">14</span>,<span class="number">215</span>,<span class="number">84</span>,<span class="number">82</span>,<span class="number">73</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">15</span>,<span class="number">216</span>,<span class="number">85</span>,<span class="number">74</span>,<span class="number">93</span>,<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">16</span>,<span class="number">221</span>,<span class="number">77</span>,<span class="number">99</span>,<span class="number">61</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">17</span>,<span class="number">222</span>,<span class="number">80</span>,<span class="number">78</span>,<span class="number">96</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">18</span>,<span class="number">223</span>,<span class="number">79</span>,<span class="number">74</span>,<span class="number">96</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">19</span>,<span class="number">224</span>,<span class="number">75</span>,<span class="number">80</span>,<span class="number">78</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>),</span><br><span class="line">  (<span class="number">20</span>,<span class="number">225</span>,<span class="number">82</span>,<span class="number">85</span>,<span class="number">63</span>,<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;department2&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="计数函数-count"><a href="#计数函数-count" class="headerlink" title="计数函数: count"></a>计数函数: count</h3><p><strong>语法</strong>: count(*), count(1), count(expr), count(distinct expr)</p><p><strong>返回值</strong>:int</p><p><strong>count(1) 和 count(*)有什么区别?</strong></p><p>count(1)和count(*) 没有区别.都只看行数,即使一行的所有字段都是null也能统计出来.</p><p><strong>count(*) 和 count(expr)的区别?</strong></p><p>count(expr) 会统计指定字段不为null的行,count(*)统计所有行.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> classId,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student_scores <span class="keyword">group</span> <span class="keyword">by</span> classId;</span><br><span class="line">OK</span><br><span class="line"><span class="keyword">NULL</span><span class="number">1</span></span><br><span class="line">class1<span class="number">11</span></span><br><span class="line">class2<span class="number">9</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> classId,<span class="built_in">count</span>(id) <span class="keyword">from</span> student_scores <span class="keyword">group</span> <span class="keyword">by</span> classId;</span><br><span class="line">OK</span><br><span class="line"><span class="keyword">NULL</span><span class="number">0</span></span><br><span class="line">class1<span class="number">11</span></span><br><span class="line">class2<span class="number">9</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发(7):JUC中的管程</title>
      <link href="/2021/12/20/java%E5%B9%B6%E5%8F%91-JUC%E7%9A%84%E7%AE%A1%E7%A8%8B/"/>
      <url>/2021/12/20/java%E5%B9%B6%E5%8F%91-JUC%E7%9A%84%E7%AE%A1%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>java SDK 并发包全称java.util.concurrent, 由并发大师Doung Lea编写,致敬,瑞思拜!</p><p>juc里边有很多工具类,让java在解决并发问题有了更多选择,管程在juc里边同样有相应的实现.Lock和Condition就是juc里的管程模型.</p><p>在讲<a href="https://din1vin.github.io/2021/12/01/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/">并发基础</a>的时候提到并发要解决的问题主要有互斥和同步,这个问题在java语言层面的解决方式是synchronized,在juc里边的就是Lock和Condition,其中Lock用于解决互斥问题,Condition用于解决同步问题.</p><p>JDK 1.6对synchronized的优化使得它在多数情形下的性能要比juc的Lock&amp;Condition更高,但是Lock&amp;Condition机制仍然是JUC轮子重造计划中不可缺少的一环.</p><h2 id="再造管程的理由"><a href="#再造管程的理由" class="headerlink" title="再造管程的理由"></a>再造管程的理由</h2><p>性能问题是否可以否认Lock&amp;Condition的地位呢?显然不能,性能问题优化一下就可以了,那Lock&amp;Condition存在的理由是什么呢?</p><p>回忆一下破坏死锁的三种方案,其中<strong>破坏不可抢占条件</strong>方案,这一点是synchronized没办法解决的,synchronized在申请资源的时候,如果申请不到,该线程就会阻塞,阻塞的线程啥也干不了,更别提释放自身的资源了.</p><p>Doung Lea在设计Lock的时候,三个API都能解决破坏不可抢占,弥补synchronized的不足.</p><p>具体一点就是:</p><h3 id="相应中断"><a href="#相应中断" class="headerlink" title="相应中断"></a>相应中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>synchronized在遇到死锁问题的时候除了重启应用以外没有任何操作唤醒阻塞的线程,Lock在死锁时可以相应中断信号,也就是说发送中断信号可以唤醒线程,那他就有机会释放自身资源,就破坏了不可抢占.</p><h3 id="支持超时"><a href="#支持超时" class="headerlink" title="支持超时"></a>支持超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>synchronized在解决等待的时候用的是死等,永久无限期的等待对方释放资源才会叫死锁,如果在尝试获取锁的时候指定超时时间,过时返回一个错误,那么这个线程也有机会释放自身的资源,同样也破坏了不可抢占条件.</p><h3 id="非阻塞申请"><a href="#非阻塞申请" class="headerlink" title="非阻塞申请"></a>非阻塞申请</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>假如线程获取失败,跳过阻塞直接返回,那么这个线程在申请不到直接释放资源,不存在僵持,也破坏了不可抢占.</p><h2 id="再造condition的理由"><a href="#再造condition的理由" class="headerlink" title="再造condition的理由"></a>再造condition的理由</h2><p>java的同步使用的线程通知机制包括wait notify和notifyAll,java语言内置的管程条件只有一个,多条件时候可能会有很多判断来决定是否wait/notify ,多个条件变量可以提高程序的可读性.</p><h3 id="用两个条件变量实现阻塞队列"><a href="#用两个条件变量实现阻塞队列" class="headerlink" title="用两个条件变量实现阻塞队列"></a>用两个条件变量实现阻塞队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;阻塞队列已经满了&quot;</span>);</span><br><span class="line">                isFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">        queue.add(t);</span><br><span class="line">        size.getAndIncrement();</span><br><span class="line">        isEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            isFull.signal();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T res=<span class="keyword">null</span>;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;阻塞队列空了&quot;</span>);</span><br><span class="line">                isEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">        res = queue.get(<span class="number">0</span>);</span><br><span class="line">        queue.remove(<span class="number">0</span>);</span><br><span class="line">        size.getAndDecrement();</span><br><span class="line">        isFull.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            isEmpty.signal();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边代码用到了ReentrantLock,翻译过来就是**可重入锁.**什么是可重入锁?就是允许同一个线程多次加锁,可重入锁内部实现可重入的机制基本上就是AQS(AbstractQueuedSynchronizer)中被volatile修饰的state,每次加锁state+1,在释放锁的时候-1,用这个保证如果加锁两次就需要释放锁两次.</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>在使用 ReentrantLock 的时候，你会发现 ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数：默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据公平策略参数创建锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() </span><br><span class="line">                : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p><h2 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="headerlink" title="用锁的最佳实践"></a>用锁的最佳实践</h2><h3 id="Lock-SDK编程范式"><a href="#Lock-SDK编程范式" class="headerlink" title="Lock SDK编程范式"></a>Lock SDK编程范式</h3><p>使用SDK Lock的时候,有一个try{ lock.lock(); }finally{ lock.unlock(); }需要重点关注的就是在finally里边释放锁.</p><h3 id="Doung-Lea推荐的用锁规则"><a href="#Doung-Lea推荐的用锁规则" class="headerlink" title="Doung Lea推荐的用锁规则"></a>Doung Lea推荐的用锁规则</h3><ol><li><p>永远只在更新对象的成员变量时加锁</p></li><li><p>永远只在访问可变的成员变量时加锁</p></li><li><p>永远不在调用其他对象的方法时加锁</p></li></ol><p>这三条规则，前两条估计你一定会认同，最后一条你可能会觉得过于严苛。但是我还是倾向于你去遵守，因为调用其他对象的方法，实在是太不安全了，也许“其他”方法里面有线程 sleep() 的调用，也可能会有奇慢无比的 I/O 操作，这些都会严重影响性能。更可怕的是，“其他”类的方法可能也会加锁，然后双重加锁就可能导致死锁.</p><p>并发问题，本来就难以诊断，所以你一定要让你的代码尽量安全，尽量简单，哪怕有一点可能会出问题，都要努力避免</p><h3 id="condition的通知机制"><a href="#condition的通知机制" class="headerlink" title="condition的通知机制"></a>condition的通知机制</h3><p>使用condition时候需要特别注意用await,signal和signAll,<code>不要用wait,notify和notifyAll</code>.如果一不小心在 Lock&amp;Condition 实现的管程里调用了 wait()、notify()、notifyAll()，那程序可就彻底玩儿完了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark 基础介绍</title>
      <link href="/2021/12/20/spark-1-spark%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/20/spark-1-spark%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="spark-基础"><a href="#spark-基础" class="headerlink" title="spark 基础"></a>spark 基础</h1><h2 id="Spark-Core-–-RDD"><a href="#Spark-Core-–-RDD" class="headerlink" title="Spark Core – RDD"></a>Spark Core – RDD</h2><p>为什么非要从RDD开始呢？虽然RDD API使用频率越来越低，但是DataFrame跟DataSet API最终都会在spark内部转化成RDD的分布式计算，如果想对Spark计算有一个知其所以然的把控，就要对RDD有足够的了解.</p><p><strong>RDD-弹性分布式数据集</strong>，是spark实现分布式计算的基石。Spark的所有特性都来自于RDD。深入理解RDD能更全面更系统的学习Spark的工作原理。</p><h3 id="RDD-的五个特性"><a href="#RDD-的五个特性" class="headerlink" title="RDD 的五个特性"></a>RDD 的五个特性</h3><p>以下是摘自Spark RDD源码中对于RDD的五个main properties 的描述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A list of partitions：</span><br><span class="line">    RDD是由多个分区组成的，分区是逻辑上的概念。RDD的计算是以分区为单位进行的。</span><br><span class="line">* A function for computing each split ：</span><br><span class="line">    作用于每个分区数据的计算函数。</span><br><span class="line">* A list of dependencies on other RDDs ：</span><br><span class="line">    RDD中保存了对于父RDD的依赖，根据依赖关系组成了Spark的DAG（有向无环图），实现了spark巧妙、容错的编程模型</span><br><span class="line">* Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</span><br><span class="line">    分区器针对键值型RDD而言的，将key传入分区器获取唯一的分区id。在shuffle中，分区器有很重要的体现。</span><br><span class="line">* Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</span><br><span class="line">    根据数据本地性的特性，获取计算的首选位置列表，尽可能的把计算分配到靠近数据的位置，减少数据的网络传输</span><br></pre></td></tr></table></figure><p>总结下来就是RDD描述了数据血缘（数据加工的步骤，DAG图的生成依据）、数据分区（分布式依据，数据由哪个Excutor计算）等。</p><p>除了上述描述所说的特性外，<strong>Spark延迟计算</strong>和Shuffle阶段划分，都跟RDD之间的“算子”有着密不可分的联系。</p><h3 id="shuffle划分，宽窄依赖"><a href="#shuffle划分，宽窄依赖" class="headerlink" title="shuffle划分，宽窄依赖"></a>shuffle划分，宽窄依赖</h3><p>很多的博客会机械化的说“宽窄依赖是父子RDD的依赖关系。窄依赖描述的是一对一的关系，宽依赖描述的是多对一关系”，这句话不对，起码不全对，窄依赖也有多个父RDD对应一个子RDD的关系，甚至多对多的笛卡尔积，也属于窄依赖。</p><p>那宽窄依赖究竟怎么分呢？</p><p><code>NarrowDependency</code> 为 parent RDD 的一个或多个分区的数据全部流入到 child RDD 的一个或多个分区，而 <code>ShuffleDependency</code> 则为 parent RDD 的每个分区的每一部分，分别流入到 child RDD 的不同分区。</p><p>这里强调了分区内部数据的整体或部分，分区内数据有按情况拆分，就属于shuffleDependency了。</p><h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><p>在刚开始接触spark的时候，还会接触到懒加载，延迟计算这类概念，给人一种很奇怪的感觉，为什么有懒加载机制？懒加载是什么样子的机制，为什么算子要区分Transformation和Action？</p><p>spark是内存计算，而RDD只是一种数据形态转换的抽象，为了行程完整的DAG以及方便计算优化，spark设计成部分算子是修改或者定义DAG节点，即Transformation算子。而另一部分算子才能触发计算，那些能触发spark计算的算子，就是所谓的Action算子。</p><p>既然说到spark算子划分，顺便看一下spark的算子描述划分吧，这是吴磊老师对于spark算子划分的表格：</p><p><img src="https://static001.geekbang.org/resource/image/a3/88/a3ec138b50456604bae8ce22cdf56788.jpg?wh=1599x1885"></p><p>action算子可以理解成DAG的终点，当开发者调用一个Action算子时，底层代码会调用sc.runJob方法，通过iter context构造job，具体一点就是：</p><p>Spark DAGScheduler会<strong>以action算子为起点，从后向前回溯DAG，并以Shuffle为边界划分Stage，基于Stage创建taskSets，并将taskSets交给TaskSheduler调度，然后交由ScheduleBackend调度资源完成具体的Task。</strong></p><p>以上加粗的文字，也可以用来回答“请简述一下spark任务提交过程”这类问题了。</p><h3 id="task是什么？"><a href="#task是什么？" class="headerlink" title="task是什么？"></a>task是什么？</h3><p>为了更好的认识task，我们先看看task有哪些属性：</p><ul><li><p>stageID： task所在的属性ID</p></li><li><p>stageAttempId: 失败重试编号</p></li><li><p>taskBinary: 任务代码</p></li><li><p>partition： task对应的RDD分区</p></li><li><p>locs： 本地倾向性</p></li></ul><p>stageId、stageAttemptId 标记了 Task 与执行阶段 Stage 的所属关系；taskBinary 则封装了隶属于这个执行阶段的用户代码；partition 就是我们刚刚说的 RDD 数据分区；locs 属性以字符串的形式记录了该任务倾向的计算节点或是 Executor ID。</p><p>不难发现，taskBinary、partition 和 locs 这三个属性，一起描述了这样一件事情：Task 应该在哪里（locs）为谁（partition）执行什么任务（taskBinary）。</p><p>通常情况下一个rdd的一个partition对应一个task，textfile等文件源task取决于block数量。</p><h2 id="Spark-SQL-–-Dataset-DataFrame"><a href="#Spark-SQL-–-Dataset-DataFrame" class="headerlink" title="Spark SQL – Dataset/DataFrame"></a>Spark SQL – Dataset/DataFrame</h2><p>RDD是分布式弹性数据集,Dataset是带数据结构信息的分布式数据集,DataFrame是Dataset的特例.</p><p>我们知道DS(DataSet/DataFrame)是在RDD之后发布的,按照技术的发布路线,新技术的出现肯定是弥补了旧技术的不足,那为什么在<u>RDD已经解决了内存上的分布式计算</u>的前提下,还要有DataFrame呢?</p><p>下图是spark使用场景占比:</p><img src="https://static001.geekbang.org/resource/image/47/75/479cd67e687a3a7cdc805b55b5bdef75.jpg" alt="img" style="zoom: 33%;" /><p>可以明显看到spark似乎专注在sql相关的数据分析场景.那么是不是真的如此呢?</p><p>标准答案是:” Spark SQL 取代 Spark Core，成为新一代的引擎内核，所有其他子框架如 Mllib、Streaming 和 Graph，都可以共享 Spark SQL 的性能优化，都能从 Spark 社区对于 Spark SQL 的投入中受益。”</p><p>但是为什么SparkSQL可以优化Spark Core呢?</p><h3 id="RDD之痛"><a href="#RDD之痛" class="headerlink" title="RDD之痛"></a>RDD之痛</h3><p>在spark RDD中 有一类”高阶算子(map,filter)”,开发者需要通过Lambda函数的形式自行提供具体的计算逻辑. 对于spark而言,只知道map要做映射,filter要过滤,只知道做什么,并不知道怎么做. 所以只能通过闭包的形式打包发送给Excutor.<code>优化空间有限</code>.</p><p>但是如果事先告诉spark,处理的数据长什么样(指定Schema),spark就能对函数进一步优化了.</p><p>所以DS跟RDD最大的区别就是一个带Schema,一个不带Schema,而DataFrame区别去DataSet的区别,也就是</p><p><u>DataFrame是DataSet[T] 的一个特例,当DataSet的每一行都是Row类型,那么它就是DataFrame.</u></p><h3 id="SparkSQL如何工作"><a href="#SparkSQL如何工作" class="headerlink" title="SparkSQL如何工作"></a>SparkSQL如何工作</h3><p>我们知道RDD的工作原理,就是 <code>申请资源-&gt;生成DAG-&gt; 划分tasks -&gt; 发送至Excutor运行</code>.</p><p>那么当我们写下 spark.sql(…)的时候,spark是怎么工作的呢?</p><p><code>Spark SQL 的核心组件有二，其一是 Catalyst 优化器，其二是 Tungsten。</code></p><h4 id="Catalyst-执行过程优化"><a href="#Catalyst-执行过程优化" class="headerlink" title="Catalyst 执行过程优化"></a>Catalyst 执行过程优化</h4><ol><li><p>逻辑计划解析:  通过DataFrame的schema信息,确认执行计划的表名,字段名,字段类型,和数据类型. (将UnResolved LogincPlan 转化为 Analyzed Logic Plan)</p></li><li><p> 逻辑计划优化: 通过<code>谓词下推</code>,<code>列裁剪</code>,<code>常量替换</code>等优化规则将Analyzed Logic Plan转化成Optimized Logic Plan.</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 谓词下推: “谓词”指代的是像用户表上“age &lt; 30”这样的过滤条件，“下推”指代的是把这些谓词沿着执行计划向下，推到离数据源最近的地方，从而在源头就减少数据扫描量</span><br><span class="line">* 列裁剪: 扫描数据源的时候,只读取那些与查询字段有关的列.(列存储性能一般优于行存储的根本原因,很多sql解析都有列裁剪技术优化)</span><br><span class="line">* 常量替换: 指的是将sql中的数学表达式替换成常量,比如 where age&gt; 12+18 会被替换成 where age&gt;30</span><br></pre></td></tr></table></figure><ol start="3"><li><p>JoinSelection: 如果在Optimized Logic Plan中出现了join, spark会根据sql相关的配置项,自动筛选更优的join策略.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. join机制 : ShuffleJoin VS BroadcastJoin</span><br><span class="line">shuffle指的是类似于RDD划分的那种通过网络传输和shuffle的join,根据 Join Keys 计算哈希值然后用哈希值对并行度取模发送到  不同的excutor.</span><br><span class="line">broadcast指的是将小表广播,参考广播变量的方式由driver生成广播表,每个excutor一份,发送一次.</span><br><span class="line">2. 关联机制 : Nested Loop Join , Sort Merge Join 和 Hash Join</span><br><span class="line">假设a表(M行)join b表(N行)</span><br><span class="line"> Nested Loop  Join 是基本保障,通过两层for循环实现.复杂度 O(M*N)</span><br><span class="line"> Sort Merge Join 前提是a,b两张表按照join key排序. 双指针遍历,复杂度O(M+N)</span><br><span class="line"> Hash Join 将小表生成hashMap, 然后根据join key在map中查找,复杂度是O(M)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注明:  还有一个情况查看逻辑解析计划看到了CartesianProduct,笛卡尔积join,这个一般是因为join忘写条件或者非等值连接导致的,不在这讨论.</p></li></ol><h4 id="Tungsten-存储结构优化"><a href="#Tungsten-存储结构优化" class="headerlink" title="Tungsten 存储结构优化"></a>Tungsten 存储结构优化</h4><p>Tungsten 又叫钨丝计划，它主要围绕内核引擎做了两方面的改进：数据结构设计和全阶段代码生成（WSCG，Whole Stage Code Generation）。</p><ol><li>Unsafe Row: 二进制数据结构,节省内存空间</li><li>WSCG: 在运行时动态重构性能更好的代码. </li></ol><p>经过上述两步优化之后,SparkSQL写好了一份调用SparkCore的代码,交给SparkCore执行,没想到吧,干活的还是它.</p>]]></content>
      
      
      <categories>
          
          <category> spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发(6): 最优线程数量</title>
      <link href="/2021/12/13/java%E5%B9%B6%E5%8F%91-%E5%88%9B%E5%BB%BA%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0/"/>
      <url>/2021/12/13/java%E5%B9%B6%E5%8F%91-%E5%88%9B%E5%BB%BA%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在写并发程序中,很容易用多线程实现并发,那么<u>“创建多少个线程是最合适的?”</u>或者<u>“Tomcat的线程数,JDBC的连接数是多少”</u></p><p>要解决这个问题,首先要分析下面两个问题:</p><ol><li>为什么要使用多线程?</li><li>多线程的应用场景有哪些?</li></ol><h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><p>使用多线程的本质是为了提升程序性能,程序性能提升带给人的最直观感受可能就是快,快,更快.但是感受无法度量,所以有了<code>吞吐量</code>和<code>延迟</code>两大重要指标.延迟指的是发出请求到收到响应这个过程的时间；延迟越短，意味着程序执行得越快，性能也就越好。 吞吐量指的是在单位时间内能处理请求的数量；吞吐量越大，意味着程序能处理的请求越多，性能也就越好。</p><p>所以使用多线程的两个基本出发点应该就是:</p><ul><li>追求更高的吞吐量</li><li>追求更低的延迟</li></ul><p>要做到这两点,要么从<strong>优化算法的方向去减少计算次数</strong>,要么从**线程方向提高硬件使用频率.**前者是算法工程师高薪的答案,后者是并发架构师高薪的原因.也可以回答为什么要用多线程.</p><h2 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h2><h3 id="提高设备使用率"><a href="#提高设备使用率" class="headerlink" title="提高设备使用率"></a>提高设备使用率</h3><p>我们知道硬件设备分为CPU(用于计算),和IO(用于读写).假设在没有使用多线程的场景下,一个任务同时具备IO和计算,</p><p>那么他的执行过程可能如下所示:</p><p><img src="https://static001.geekbang.org/resource/image/d1/22/d1d7dfa1d574356cc5cb1019a4b7ca22.png" alt="img"></p><p>这个时候CPU和IO设备的使用率都是50%.(IO设备工作的时候CPU不计算,CPU计算的时候没有IO操作.)</p><p>这个时候如果有两个线程,</p><p>执行过程会变成这样:</p><p><img src="https://static001.geekbang.org/resource/image/68/2c/68a415b31b72844eb81889e9f0eb3f2c.png" alt="img"></p><p>此时CPU和IO设备的使用率都达到了100%.(IO设备跟CPU几乎一直在工作).</p><p>上例子说明了多线程同时执行两个任务,提高了吞吐量.</p><h3 id="缩短计算时间"><a href="#缩短计算时间" class="headerlink" title="缩短计算时间"></a>缩短计算时间</h3><p>上述任务CPU计算和IO操作各占50%,你可能会问”假如我全部都是计算任务,没有IO的情况下,用多个线程不是增加线程切换消耗吗?”</p><p>单核情况下确实如此,但是现在的CPU都是多核CPU.</p><p>通过Fork/Join等框架, 可以把任务拆分到多个CPU同时计算,每个任务算一部分,单机的MapReduce.</p><p>例如要计算 sum(1,2,3….100亿).我们在4核cpu可以用fork/join拆成CPU1 计算[0,25亿).CPU2计算[25亿,50亿)….</p><p>达到类似于下图的计算结果.然后将每个core的结果累加.</p><p><img src="https://static001.geekbang.org/resource/image/95/8c/95367d49f55e0dfd099f2749c532098c.png" alt="img"></p><p>原本累加100亿次的任务变成了25亿次,缩短了计算时间.</p><h2 id="创建多少个线程合适"><a href="#创建多少个线程合适" class="headerlink" title="创建多少个线程合适?"></a>创建多少个线程合适?</h2><p>按照实际的应用场景! </p><p>我们的计算任务通常是IO和CPU计算交叉执行的.由于IO设备较CPU慢几十万倍,所以把这种任务称为IO密集型任务,反之则是CPU密集型.对于是否IO密集的任务,最佳线程数算法是不同的.</p><p>假如是CPU密集型:</p><p>CPU密集型的优化方案跟上面举例的多核减少计算时间一致,所以理论上”线程数=CPU核数”就是最佳的,但是工程上基本会设置为”CPU core +1” 这样的话当线程因为偶尔的原因bug时有额外线程可以顶上.</p><p>对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程，如下图所示：CPU 在 A、B、C 三个线程之间切换，对于线程 A，当 CPU 从 B、C 切换回来时，线程 A 正好执行完 I/O 操作。这样 CPU 和 I/O 设备的利用率都达到了 100%。</p><p><img src="https://static001.geekbang.org/resource/image/98/cb/98b71b72f01baf5f0968c7c3a2102fcb.png" alt="img"></p><p>通过上面这个例子，我们会发现，对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以`总结出这样一个公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最佳线程数 =1 +（I/O 耗时 / CPU 耗时）</span><br></pre></td></tr></table></figure><p>不过上面这个公式是针对单核 CPU 的，至于多核 CPU，也很简单，只需要等比扩大就可以了，计算公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]</span><br></pre></td></tr></table></figure><p>参考:<strong><a href="https://time.geekbang.org/column/article/86666">https://time.geekbang.org/column/article/86666</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive(1): 基础函数</title>
      <link href="/2021/12/13/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2021/12/13/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><h3 id="等值比较-与-lt-gt"><a href="#等值比较-与-lt-gt" class="headerlink" title="等值比较 : =与&lt;=&gt;"></a>等值比较 : =与&lt;=&gt;</h3><p><strong>说明</strong>: = 和 &lt;=&gt; 都是 判断A,B两个值是否相等,在AB都不为空的时候二者效果一样</p><p><strong>不同点</strong>: AB都为null的时候 &lt;=&gt;返回True, = 返回False</p><h3 id="不等值比较-与-lt-gt"><a href="#不等值比较-与-lt-gt" class="headerlink" title="不等值比较: != 与 &lt;&gt;"></a>不等值比较: != 与 &lt;&gt;</h3><p><strong>说明</strong>: 与传统数据库语言一致</p><h3 id="大于、小于、大于等于、小于等于-gt-lt-gt-lt"><a href="#大于、小于、大于等于、小于等于-gt-lt-gt-lt" class="headerlink" title="大于、小于、大于等于、小于等于: &gt; ,&lt; ,&gt;=,&lt;="></a>大于、小于、大于等于、小于等于: &gt; ,&lt; ,&gt;=,&lt;=</h3><p><strong>说明</strong>: 与传统数据库语言一致</p><h3 id="区间比较"><a href="#区间比较" class="headerlink" title="区间比较:"></a>区间比较:</h3><p><strong>语法</strong>: A [not] between B and C</p><p><strong>说明</strong>: 等价于 B&lt;=A&lt;C</p><h3 id="空值判断-is-null-is-not-null"><a href="#空值判断-is-null-is-not-null" class="headerlink" title="空值判断: is null , is not null"></a>空值判断: is null , is not null</h3><p> <strong>说明</strong>: 与传统数据库语言一致</p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p><strong>描述:</strong> 如果字符串 A 或者字符串 B 为 NULL，则返回 NULL;如果字符串 A 符合表达式 B 的正则语法，则为 TRUE;否则为 FALSE。B 中字符”_”表示任意单个字符，而字 符”%”表示任意数量的字符。</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="string">&#x27;football&#x27;</span> <span class="keyword">like</span> <span class="string">&#x27;foot%&#x27;</span>;</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="string">&#x27;football&#x27;</span> <span class="keyword">like</span> <span class="string">&#x27;foot__&#x27;</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 否定时候用 NOT A like B.</p></blockquote><h3 id="正则like-rlike-和-regexp"><a href="#正则like-rlike-和-regexp" class="headerlink" title="正则like: rlike 和 regexp"></a>正则like: rlike 和 regexp</h3><p><strong>说明</strong>: 符合java 正则表达式的写法</p><p><strong>举例</strong>: 判断一个字符串是否全为数字:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="string">&#x27;123456&#x27;</span> rlike <span class="string">&#x27;^\\d+$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="string">&#x27;123456&#x27;</span> regexp <span class="string">&#x27;^\\d+$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="数学操作"><a href="#数学操作" class="headerlink" title="数学操作"></a>数学操作</h2><p>数学操作的 AB两个都必须是数值类型</p><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除: +,-,*,/"></a>加减乘除: +,-,*,/</h3><p><strong>说明</strong>: 加减类型 int ± int = int,  int ± double = double</p><p>乘法结果类型是AB的最小父类型(详情见数据类型的继承关系)</p><p>除法的结果是 double.</p><blockquote><p>注意:hive 中最高精度的数据类型是 double,只精确到小数点后 16 位，在做除法运算的 时候要特别注意</p></blockquote><h3 id="取余数"><a href="#取余数" class="headerlink" title="取余数: %"></a>取余数: %</h3><p><strong>说明</strong>: 取余结果类型是AB的最小父类型(详情见数据类型的继承关系)</p><h3 id="位操作与、或、非、异或-amp"><a href="#位操作与、或、非、异或-amp" class="headerlink" title="位操作与、或、非、异或: &amp;,|,~,^"></a>位操作与、或、非、异或: &amp;,|,~,^</h3><p><strong>说明</strong>: 与数学逻辑一致.</p><h2 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h2><h3 id="AND-amp-amp-OR-NOT"><a href="#AND-amp-amp-OR-NOT" class="headerlink" title="AND(&amp;&amp;), OR(||),NOT(!)"></a>AND(&amp;&amp;), OR(||),NOT(!)</h3><p>**说明:**与主流数据库一致</p><h2 id="复合类型构造函数"><a href="#复合类型构造函数" class="headerlink" title="复合类型构造函数"></a>复合类型构造函数</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><strong>语法</strong>: array(v1,v2,v3…)</p><p><strong>操作类型</strong>: array</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>**语法 **: map(k1,v1,k2,v2,…)<br><strong>操作类型</strong>: map<br><strong>说明</strong>:使用给定的 key-value 对，构造一个 map 数据结构</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> map(<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>,<span class="string">&#x27;v2&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">&#123;&quot;k2&quot;:&quot;v2&quot;,&quot;k1&quot;:&quot;v1&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>**语法 **: struct(v1,v2,v3,…)<br><strong>操作类型</strong>:struct</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认构造是 col1,col2...</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> struct(<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="literal">FALSE</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">&#123;&quot;col1&quot;:<span class="number">1</span>,&quot;col2&quot;:&quot;aaa&quot;,&quot;col3&quot;:<span class="literal">false</span>&#125;</span><br><span class="line"><span class="comment">-- 如果是已经定义的struct</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t(x struct<span class="operator">&lt;</span>name:string,age:<span class="type">int</span><span class="operator">&gt;</span> );</span><br><span class="line">OK</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(struct(<span class="string">&#x27;tom&#x27;</span>,<span class="number">22</span>) );</span><br><span class="line">OK</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t;</span><br><span class="line">OK</span><br><span class="line">&#123;name:<span class="string">&#x27;tom&#x27;</span>, age: <span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="named-struct"><a href="#named-struct" class="headerlink" title="named_struct"></a>named_struct</h3><p><strong>语法</strong>: named_struct(k1,v1,k2,v2,…)</p><p><strong>操作类型</strong>: sturct</p><p><strong>说明</strong>: 类似map构造指定列名的struct</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> map(<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>,<span class="string">&#x27;v2&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">&#123;&quot;k2&quot;:&quot;v2&quot;,&quot;k1&quot;:&quot;v1&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型操作函数"><a href="#复合类型操作函数" class="headerlink" title="复合类型操作函数"></a>复合类型操作函数</h2><h3 id="Array取值"><a href="#Array取值" class="headerlink" title="Array取值"></a>Array取值</h3><p><strong>语法:</strong> A[n]</p><p><strong>操作类型</strong>: array</p><p><strong>说明</strong>: 与Java一样从下标0开始取第n+1个元素.</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)[<span class="number">0</span>] <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Map取值"><a href="#Map取值" class="headerlink" title="Map取值"></a>Map取值</h3><p><strong>语法</strong>: A[k]</p><p><strong>操作类型:</strong> Map</p><p><strong>说明</strong>: 与Java一样按key取值,如果key不存在,返回null</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> map(<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;v1&#x27;</span>)[<span class="string">&#x27;k1&#x27;</span>] <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><h3 id="Struct取值"><a href="#Struct取值" class="headerlink" title="Struct取值"></a>Struct取值</h3><p><strong>语法:</strong> A.k</p><p><strong>操作类型</strong>: struct</p><p><strong>说明</strong>: 返回A中k列的值</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> struct(<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;b2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>).col1 <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">a1</span><br></pre></td></tr></table></figure><h3 id="Array长度"><a href="#Array长度" class="headerlink" title="Array长度"></a>Array长度</h3><p><strong>语法:</strong> size(Array a)</p><p><strong>说明:</strong> 返回Array类型的长度</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> size(<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Map大小"><a href="#Map大小" class="headerlink" title="Map大小"></a>Map大小</h3><p><strong>语法:</strong> size(Map a)</p><p><strong>说明:</strong> 返回map类型的a的长度</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> size(map(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="数组中是否包含元素"><a href="#数组中是否包含元素" class="headerlink" title="数组中是否包含元素"></a>数组中是否包含元素</h3><p><strong>语法:</strong> array_contains(Array a, e)</p><p><strong>返回值:</strong> boolean</p><p><strong>说明:</strong> 返回a数组中是否包含e元素.</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> array_contains(<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="获取map中的所有key"><a href="#获取map中的所有key" class="headerlink" title="获取map中的所有key"></a>获取map中的所有key</h3><p><strong>语法:</strong> map_keys(map a)</p><p><strong>返回类型:</strong> array</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> map_keys(map(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="获取map中的所有value"><a href="#获取map中的所有value" class="headerlink" title="获取map中的所有value"></a>获取map中的所有value</h3><p>语法: map_values(map a)</p><p><strong>返回类型:</strong> array</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> map_values(map(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><strong>语法</strong>: sort_array(array a)</p><p><strong>说明:</strong> 返回数组的增序排序结果</p><p>**返回类型: **array</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sort_array(<span class="keyword">array</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>)) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="数学计算函数"><a href="#数学计算函数" class="headerlink" title="数学计算函数"></a>数学计算函数</h2><h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p><strong>语法:</strong> round(double A, scale=0)=bigint/double</p><p><strong>说明:</strong> 对double的A类型进行四舍五入,scale是小数点后保留的位数,不指定时为0.scale不指定时返回bigint类型,指定精度时返回double类型.</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> round(<span class="number">3.14</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> round(<span class="number">3.1415926</span>,<span class="number">3</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">3.142</span></span><br></pre></td></tr></table></figure><h3 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h3><p><strong>语法:</strong> floor(double A)</p><p><strong>操作类型</strong>: double</p><p><strong>返回值类型</strong>: bigint</p><p><strong>举例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">3.14</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h3><p><strong>语法</strong>: ceil(double A) 或 ceiling(double A)</p><p><strong>操作类型:</strong> double</p><p><strong>返回值类型:</strong> bigint</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">3.14</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">ceiling</span>(<span class="number">3.14</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="一以内随机数"><a href="#一以内随机数" class="headerlink" title="一以内随机数"></a>一以内随机数</h3><p><strong>语法</strong>: rand(),rand(int seed)</p><p><strong>返回值类型</strong>: double</p><p><strong>说明</strong>: 类似Java的random,如果指定seed,将得到稳定随机数</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand() <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">0.7853598658412376</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand() <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">0.6785479262413191</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand(<span class="number">100</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">0.7220096548596434</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rand(<span class="number">100</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">0.7220096548596434</span></span><br></pre></td></tr></table></figure><h3 id="自然指数e-x"><a href="#自然指数e-x" class="headerlink" title="自然指数e^x^"></a>自然指数e^x^</h3><p><strong>语法:</strong> exp(double x)</p><p><strong>返回类型:</strong> double</p><p><strong>举例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">exp</span>(<span class="number">2</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">7.38905609893065</span></span><br></pre></td></tr></table></figure><h3 id="自然对数-lnX"><a href="#自然对数-lnX" class="headerlink" title="自然对数 lnX"></a>自然对数 lnX</h3><p><strong>语法:</strong> ln(double x)</p><p><strong>返回类型:</strong> double</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">ln</span>(<span class="number">7.38905609893065</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure><h3 id="常用对数-log10X"><a href="#常用对数-log10X" class="headerlink" title="常用对数 log10X"></a>常用对数 log<del>10</del>X</h3><p><strong>语法</strong>: log10(double x)</p><p><strong>返回类型:</strong> double</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">log10</span>(<span class="number">100</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure><h3 id="以2为底对数-log2X"><a href="#以2为底对数-log2X" class="headerlink" title="以2为底对数 log2X"></a>以2为底对数 log<del>2</del>X</h3><p><strong>语法:</strong> log2(double x)</p><p><strong>返回类型:</strong> double</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> log2(<span class="number">8</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><h3 id="指数函数-a-x"><a href="#指数函数-a-x" class="headerlink" title="指数函数 a^x^"></a>指数函数 a^x^</h3><p>语法 pow(double a,double x) 或者power(double a, double x)</p><p>返回值: double</p><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> pow(<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">power</span>(<span class="number">2</span>,<span class="number">10</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">1024.0</span></span><br></pre></td></tr></table></figure><h3 id="对数函数-logna"><a href="#对数函数-logna" class="headerlink" title="对数函数 logna"></a>对数函数 log<del>n</del>a</h3><p><strong>语法:</strong> log(double n, double a)</p><p><strong>返回值:</strong> double</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">log</span>(<span class="number">3</span>,<span class="number">27</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><h3 id="开方函数-n-√a"><a href="#开方函数-n-√a" class="headerlink" title="开方函数 ^n^√a"></a>开方函数 ^n^√a</h3><p><strong>语法:</strong>  开根号(2次方)用sqrt(n),开n次方用 pow(a,1/n)</p><p><strong>返回值:</strong> double</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">sqrt</span>(<span class="number">16</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p><strong>语法:</strong> pmod(double x,double y)</p><p><strong>说明:</strong> 返回 x%y的正余数</p><h3 id="取反函数"><a href="#取反函数" class="headerlink" title="取反函数"></a>取反函数</h3><p><strong>语法:</strong> negative( double x)</p><p><strong>说明:</strong> 返回 -x</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table><thead><tr><th>函数名</th><th>用法</th><th>输入类型</th><th>输出类型</th></tr></thead><tbody><tr><td>正弦函数</td><td>sin(x)</td><td>double</td><td>double</td></tr><tr><td>反正弦函数</td><td>asin(x)</td><td>double</td><td>double</td></tr><tr><td>余弦函数</td><td>cos(x)</td><td>double</td><td>double</td></tr><tr><td>反余弦函数</td><td>acos(x)</td><td>double</td><td>double</td></tr><tr><td>正切函数</td><td>tan(x)</td><td>double</td><td>double</td></tr><tr><td>反正切函数</td><td>atan(x)</td><td>double</td><td>double</td></tr></tbody></table><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><strong>语法:</strong> bin(bigint n)</p><p><strong>返回值:</strong> string</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> bin(<span class="number">7</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure><h3 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h3><p><strong>语法:</strong> hex(bigint a)</p><p><strong>返回值:</strong> string</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> hex(<span class="number">18</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="普通进制转换"><a href="#普通进制转换" class="headerlink" title="普通进制转换"></a>普通进制转换</h3><blockquote><p>记住这一个通用的就行,其他的可以不知道</p></blockquote><p><strong>语法:</strong> conv(num, int from_base,int to_base)</p><p><strong>说明:</strong> num可以是数值类型也可以是合法的string类型. 把num 从 from_base进制转换为to_base进制</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 将18从10进制转换成16进制</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> conv(<span class="number">18</span>,<span class="number">10</span>,<span class="number">16</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="类型转换-cast"><a href="#类型转换-cast" class="headerlink" title="类型转换 cast"></a>类型转换 cast</h3><p><strong>语法:</strong> cast(a as int)</p><p><strong>说明:</strong> 将 a 转换成 as后面的类型并返回</p><p><strong>返回类型:</strong> 指定的类型</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;1&#x27;</span> <span class="keyword">as</span> <span class="type">int</span>) <span class="keyword">from</span> test;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="时间日期函数"><a href="#时间日期函数" class="headerlink" title="时间日期函数"></a>时间日期函数</h2><h3 id="时间戳转日期字符串"><a href="#时间戳转日期字符串" class="headerlink" title="时间戳转日期字符串"></a>时间戳转日期字符串</h3><p><strong>语法:</strong> from_unixtime(bigint tms,fmt=’yyyy-MM-dd HH:mm:ss’)</p><p><strong>说明</strong>: 把时间戳转换成日期字符串格式,不指定格式的时候为yyyy-MM-dd HH:mm:ss</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> from_unixtime(<span class="number">1786587545</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">2026</span><span class="number">-08</span><span class="number">-13</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">05</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> from_unixtime(<span class="number">1323308943</span>,<span class="string">&#x27;yyyyMMdd&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">20111208</span></span><br></pre></td></tr></table></figure><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><p><strong>语法:</strong> unix_timestamp()</p><p><strong>返回类型:</strong> bigint</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp() <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1632814841</span></span><br></pre></td></tr></table></figure><h3 id="日期转时间戳"><a href="#日期转时间戳" class="headerlink" title="日期转时间戳"></a>日期转时间戳</h3><p><strong>语法:</strong> unix_timestamp(string date)</p><p><strong>返回类型:</strong> bigint</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">1609430400</span></span><br></pre></td></tr></table></figure><h3 id="指定格式日期转时间戳"><a href="#指定格式日期转时间戳" class="headerlink" title="指定格式日期转时间戳"></a>指定格式日期转时间戳</h3><p>**语法:**unix_timestamp(string date,string pattern)</p><p>**返回类型:**bigint</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2021-01-01&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1609430400</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串的日期"><a href="#获取时间字符串的日期" class="headerlink" title="获取时间字符串的日期"></a>获取时间字符串的日期</h3><p><strong>语法:</strong> to_date(string dateString)</p><p>**返回类型:**string</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> to_date(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-01</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的年份"><a href="#获取时间字符串中的年份" class="headerlink" title="获取时间字符串中的年份"></a>获取时间字符串中的年份</h3><p><strong>语法:</strong> year(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">2021</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2021-09-11&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">2021</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的月份"><a href="#获取时间字符串中的月份" class="headerlink" title="获取时间字符串中的月份"></a>获取时间字符串中的月份</h3><p><strong>语法:</strong> month(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2021-09-11&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的天"><a href="#获取时间字符串中的天" class="headerlink" title="获取时间字符串中的天"></a>获取时间字符串中的天</h3><p><strong>语法:</strong> day(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">day</span>(<span class="string">&#x27;2021-09-11&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的小时"><a href="#获取时间字符串中的小时" class="headerlink" title="获取时间字符串中的小时"></a>获取时间字符串中的小时</h3><p><strong>语法:</strong> hour(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">hour</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的分钟"><a href="#获取时间字符串中的分钟" class="headerlink" title="获取时间字符串中的分钟"></a>获取时间字符串中的分钟</h3><p><strong>语法:</strong> minute(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">minute</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的秒"><a href="#获取时间字符串中的秒" class="headerlink" title="获取时间字符串中的秒"></a>获取时间字符串中的秒</h3><p><strong>语法:</strong> second(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">second</span>(<span class="string">&#x27;2021-01-01 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="获取时间字符串中的周"><a href="#获取时间字符串中的周" class="headerlink" title="获取时间字符串中的周"></a>获取时间字符串中的周</h3><p><strong>语法:</strong> weekofyear(string dateString)</p><p><strong>返回类型:</strong> int</p><p><strong>举例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> weekofyear(<span class="string">&#x27;2021-10-10 19:01:01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">39</span></span><br></pre></td></tr></table></figure><h3 id="日期相减"><a href="#日期相减" class="headerlink" title="日期相减"></a>日期相减</h3><p><strong>语法</strong>: datediff(string enddate,string startdate)</p><p><strong>返回值:</strong> int</p><p><strong>说明</strong>: 如果enddate比startdate小,会返回负数.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> datediff(<span class="string">&#x27;2021-12-01&#x27;</span>,<span class="string">&#x27;2021-11-01&#x27;</span>) <span class="keyword">from</span> test;</span><br><span class="line">OK</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="日期增加"><a href="#日期增加" class="headerlink" title="日期增加"></a>日期增加</h3><p><strong>语法</strong>: date_add(string date,int delta)</p><p><strong>返回值:</strong> String</p><p><strong>说明</strong>: 返回指定日期加上delta的结果,只支持 ‘yyyy-MM-dd …’格式的日期,delta可以是负数.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="string">&#x27;2021-01-01&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-02</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="string">&#x27;2021-01-01 00:19:06&#x27;</span>,<span class="number">-10</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-22</span></span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> date_add(<span class="string">&#x27;2021/01/01 10:00:00.777&#x27;</span>,<span class="number">-10</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h3 id="日期减少"><a href="#日期减少" class="headerlink" title="日期减少"></a>日期减少</h3><p><strong>语法</strong>: date_sub(string date,int delta)</p><p><strong>返回值</strong>: String</p><p><strong>说明</strong>: 与日期增加用法相似,可以理解成 date_sub(date,delta) = date_add(date, - delta)</p><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h3 id="判断函数-if"><a href="#判断函数-if" class="headerlink" title="判断函数 if"></a>判断函数 if</h3><p><strong>语法</strong>: if(bool condition, T trueValue,T falseValue)</p><p><strong>返回值</strong>: T</p><p><strong>说明:</strong> 当condition为True返回trueValue,否则返回falseValue.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> if(<span class="keyword">null</span><span class="operator">&lt;=&gt;</span><span class="keyword">null</span>,<span class="string">&#x27;nice&#x27;</span>,<span class="string">&#x27;sorry&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">nice</span><br></pre></td></tr></table></figure><h3 id="非空查找-coalesce"><a href="#非空查找-coalesce" class="headerlink" title="非空查找 coalesce"></a>非空查找 coalesce</h3><p><strong>语法:</strong> coalesce(T v1, T… v)</p><p><strong>返回值</strong>: T</p><p><strong>说明</strong>: 按照参数顺序返回第一个非null值.如果所有值都为null,返回null.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="模式匹配-case"><a href="#模式匹配-case" class="headerlink" title="模式匹配 case"></a>模式匹配 case</h3><p><strong>语法1</strong>: case x when x1 then y1 when x2 then y2 else y0 end</p><p> <strong>说明:</strong> 类似于java swith case变量匹配.</p><p><strong>语法2</strong>: case when b1 then y1 when b2 then y2 else b3 end</p><p><strong>说明</strong>: 类似 if…else if… else if…else的匹配逻辑.</p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="字符串ASCII码-ascii"><a href="#字符串ASCII码-ascii" class="headerlink" title="字符串ASCII码 ascii"></a>字符串ASCII码 ascii</h3><p><strong>语法</strong>: ascii(string str)</p><p><strong>返回值</strong>: int</p><p><strong>说明</strong>:返回str中<u>第一个字符</u>的ascii码.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ascii(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.03</span> seconds, Fetched: <span class="number">1</span> <span class="type">row</span>(s)</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ascii(<span class="string">&#x27;anc&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><h3 id="字符串的binary"><a href="#字符串的binary" class="headerlink" title="字符串的binary"></a>字符串的binary</h3><p><strong>语法</strong>: binary(String binary)</p><p><strong>返回值</strong>: binary</p><p><strong>说明</strong>: 数据格式变化,显示结果与原来的一致.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="type">binary</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="base64-字符串"><a href="#base64-字符串" class="headerlink" title="base64 字符串"></a>base64 字符串</h3><p><strong>语法</strong>: base64(binary bin)</p><p><strong>返回值</strong>: string</p><p><strong>说明</strong>: 返回二进制串bin的base64编码串.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> base64(<span class="type">binary</span>(<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line">OK</span><br><span class="line">aGVsbG8<span class="operator">=</span></span><br></pre></td></tr></table></figure><h3 id="字符串连接-concat"><a href="#字符串连接-concat" class="headerlink" title="字符串连接 concat"></a>字符串连接 concat</h3><p>**语法:**concat(string str1, string…. str2)</p><p>**返回值:**string</p><p><strong>说明</strong>: 返回str1根str2的拼接字符串.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> concat(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;ne&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">mine</span><br></pre></td></tr></table></figure><h3 id="分隔符拼接字符串-concat-ws"><a href="#分隔符拼接字符串-concat-ws" class="headerlink" title="分隔符拼接字符串: concat_ws"></a>分隔符拼接字符串: concat_ws</h3><p><strong>语法:</strong> concat_ws(string sep,string… str) 或者 concat_ws(string sep, array&lt;string&gt; str )</p><p><strong>返回值:</strong> string </p><p><strong>说明</strong>: 用分隔符sep拼接多个字符串.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> concat_ws(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;kobe&#x27;</span>,<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">kobe,james</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.027</span> seconds, Fetched: <span class="number">1</span> <span class="type">row</span>(s)</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> concat_ws(<span class="string">&#x27;,&#x27;</span>,<span class="keyword">array</span>(<span class="string">&#x27;kobe&#x27;</span>,<span class="string">&#x27;james&#x27;</span>));</span><br><span class="line">OK</span><br><span class="line">kobe,james</span><br></pre></td></tr></table></figure><h3 id="小数位格式化-format-number"><a href="#小数位格式化-format-number" class="headerlink" title="小数位格式化: format_number"></a>小数位格式化: format_number</h3><p><strong>语法</strong>:format_number(number x,int d)</p><p><strong>返回值</strong>:String</p><p>**说明:**保留小数点后d位数字的四舍五入.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> format_number(<span class="number">3.14159</span>,<span class="number">2</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure><h3 id="字符串截取-substr-substring"><a href="#字符串截取-substr-substring" class="headerlink" title="字符串截取: substr,substring"></a>字符串截取: substr,substring</h3><p><strong>语法:</strong> substr(string s,int start,int len=Max), substring(string s,int start,int len=Max)</p><p><strong>返回值</strong>: string</p><p><strong>说明</strong>:  1. start从1开始,</p><ol start="2"><li>不指定len的时候默认从start开始到字符串结束.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span><span class="keyword">select</span> substr(<span class="string">&#x27;welcome hive&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">OK </span><br><span class="line">come hive</span><br><span class="line"></span><br><span class="line">hive<span class="operator">&gt;</span><span class="keyword">select</span> substr(<span class="string">&#x27;welcome hive&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">OK </span><br><span class="line">come</span><br></pre></td></tr></table></figure><h3 id="字符串查找-instr"><a href="#字符串查找-instr" class="headerlink" title="字符串查找: instr"></a>字符串查找: instr</h3><p><strong>语法:</strong> instr(string str,string substr)</p><p>**返回值:**int</p><p><strong>说明</strong>: 查找substr在str中首次出现的index(index从1开始)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> instr(&quot;welcome&quot;,&quot;come&quot;);</span><br><span class="line">OK</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="字符串长度-length"><a href="#字符串长度-length" class="headerlink" title="字符串长度: length"></a>字符串长度: length</h3><p><strong>语法:</strong> length(string str)</p><p>**返回值:**int</p><p><strong>说明</strong>: 返回str的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> length(&quot;welcome&quot;);</span><br><span class="line">OK</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>参考: <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-LogicalOperators">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-LogicalOperators</a></p><h3 id="字符串查找函数-locate"><a href="#字符串查找函数-locate" class="headerlink" title="字符串查找函数: locate"></a>字符串查找函数: locate</h3><p><strong>语法:</strong>  locate(string substr, string str,int pos=1)</p><p>**返回值:**int</p><p><strong>说明</strong>: 查找substr在str中,从pos开始首次出现的index(index从1开始)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> locate(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;ababcd&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">1</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> locate(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;ababcd&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="字符串格式化参数-printf"><a href="#字符串格式化参数-printf" class="headerlink" title="字符串格式化参数: printf"></a>字符串格式化参数: printf</h3><p><strong>语法:</strong>  printf(String format,Obj… args)</p><p>**返回值:**string</p><p><strong>说明</strong>:与java的String.format相似.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> printf(<span class="string">&#x27;hello,%s %d&#x27;</span>,<span class="string">&#x27;hive&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">OK</span><br><span class="line">hello,hive <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="字符串转map-str-to-map"><a href="#字符串转map-str-to-map" class="headerlink" title="字符串转map : str_to_map"></a>字符串转map : str_to_map</h3><p><strong>语法</strong>: str_to_map(string text,string entryDelimiter=’,’, string kvDelemiter=’:’ )</p><p><strong>返回值</strong>: map&lt;string,string&gt;</p><p><strong>说明</strong>: 将字符串按照指定分隔符转成map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select str_to_map(&quot;a:1,b:3&quot;);</span><br><span class="line">OK</span><br><span class="line">&#123;&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;3&quot;&#125;</span><br><span class="line">hive&gt; select str_to_map(&quot;a=1,b=3&quot;,&#x27;,&#x27;,&#x27;=&#x27;);</span><br><span class="line">OK</span><br><span class="line">&#123;&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;3&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转大写-upper-ucase"><a href="#字符串转大写-upper-ucase" class="headerlink" title="字符串转大写: upper, ucase"></a>字符串转大写: upper, ucase</h3><p><strong>语法</strong>: upper(string A) ucase(string A) </p><p><strong>返回值</strong>: string</p><p><strong>说明</strong>:返回字符串 A 的大写格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">HELLO</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ucase(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">HELLO</span><br></pre></td></tr></table></figure><h3 id="字符串转小写-lower-lcase"><a href="#字符串转小写-lower-lcase" class="headerlink" title="字符串转小写: lower, lcase"></a>字符串转小写: lower, lcase</h3><p><strong>语法</strong>: lower(string A) lcase(string A) </p><p><strong>返回值</strong>: string</p><p><strong>说明</strong>:返回字符串 A 的小写格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;HELLO&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">hello</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> lcase(<span class="string">&#x27;HELLO&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="去除空格-trim-两边-ltrim-左边-rtrim-右边"><a href="#去除空格-trim-两边-ltrim-左边-rtrim-右边" class="headerlink" title="去除空格: trim(两边),ltrim(左边),rtrim(右边)"></a>去除空格: trim(两边),ltrim(左边),rtrim(右边)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">trim</span>(&quot;  edg   &quot;);</span><br><span class="line">OK</span><br><span class="line">edg</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> ltrim(&quot;  edg   &quot;);</span><br><span class="line">OK</span><br><span class="line">edg   </span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> rtrim(&quot;  edg   &quot;);</span><br><span class="line">OK</span><br><span class="line">  edg</span><br></pre></td></tr></table></figure><h3 id="左补齐函数-lpad"><a href="#左补齐函数-lpad" class="headerlink" title="左补齐函数: lpad"></a>左补齐函数: lpad</h3><p><strong>语法</strong>: lpad(string str, int len, string pad)</p><p><strong>返回值</strong>: string</p><p><strong>说明:</strong> 用pad将str左填充至长度为len.如果长度比原来小就截取字符串.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> lpad(&quot;hello&quot;,<span class="number">10</span>,&quot;#&quot;);</span><br><span class="line">OK</span><br><span class="line">#####hello</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> lpad(&quot;hello&quot;,<span class="number">3</span>,&quot;#@&quot;);</span><br><span class="line">OK</span><br><span class="line">hel</span><br></pre></td></tr></table></figure><h3 id="右补齐函数-rpad"><a href="#右补齐函数-rpad" class="headerlink" title="右补齐函数: rpad"></a>右补齐函数: rpad</h3><p>同上lpad,只不过填充方向位右边.</p><h3 id="字符串的hashcode-hash"><a href="#字符串的hashcode-hash" class="headerlink" title="字符串的hashcode : hash"></a>字符串的hashcode : hash</h3><p><strong>语法</strong>: hash(string… str)</p><p><strong>返回值</strong>: string</p><p><strong>说明:</strong> 将所有str拼接之后取hash</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> hash(<span class="string">&#x27;aba&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">96352</span></span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">select</span> hash(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line"><span class="number">96352</span></span><br></pre></td></tr></table></figure><p>参考: <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-LogicalOperators">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-LogicalOperators</a></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发(5):线程通信</title>
      <link href="/2021/12/09/java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2021/12/09/java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="自旋机制"><a href="#自旋机制" class="headerlink" title="自旋机制"></a>自旋机制</h2><p>在讲synchronized的锁膨胀机制的时候,有提到从轻量级锁升级到重量级锁时会基于线程自旋次数来判断是否需要升级,那么如何来具体的描述自旋呢?</p><p>我们把线程理解成一辆网约车,把获取同步资源的限定条件类比成’乘客到达上车点’这一条件,如果乘客指定一个禁停区域上车,网约车有可能提前到达,但是乘客还没到(共享资源不可用),为了不被禁停贴罚单,网约车司机通常会绕一圈再回到上车点,再次看这个乘客有没有到达上车点.这种自己转一圈等下一次机会的现象,就是很现实的”自旋”.</p><p>对应到编程领域,自旋其实就是循环判断条件是否满足–你可以理解成while关键字.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!条件满足);</span><br></pre></td></tr></table></figure><p>为什么需要有这个机制呢?  假设上车点没有禁停,但是车子启停代价很大.(线程状态切换会带来较大开销),那其实转一圈再看一下就是一个不错的解决方案.</p><h2 id="线程的等待通知机制"><a href="#线程的等待通知机制" class="headerlink" title="线程的等待通知机制"></a>线程的等待通知机制</h2><p>在我们知道应用场景的锁竞争激烈的前提下,如果使用while,会造成线程饥饿(工作线程长期无法获得共享资源.)因为一直无法获取共享资源,如果一直用while自旋判断,相当于这个线程一直在工作,对于CPU资源是一种浪费.</p><p>这个时候,java线程的<code>等待--通知</code>机制就派上用场了.</p><p>拿前文提到的一次性申请所有资源破坏死锁条件的解决方案来举例,使用该机制的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; hasBeenAllocated = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//用来记录哪些账本已经被拿走了</span></span><br><span class="line">    <span class="comment">//同时申请两个资源的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(T from,T to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasBeenAllocated.contains(from) ||hasBeenAllocated.contains(to))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait(); <span class="comment">// 将线程挂起等待通知</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception)&#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasBeenAllocated.add(from);</span><br><span class="line">        hasBeenAllocated.add(to);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(T from, T to)</span></span>&#123;</span><br><span class="line">        hasBeenAllocated.remove(from);</span><br><span class="line">        hasBeenAllocated.remove(to);</span><br><span class="line">        notifyAll(); <span class="comment">// 释放资源唤醒所有挂起的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="notify-和-notifyAll"><a href="#notify-和-notifyAll" class="headerlink" title="notify() 和 notifyAll()"></a>notify() 和 notifyAll()</h2><p>在上述代码中,使用的是notifyAll(),为什么不使用notify()呢?</p><p>notify()会随机通知等待队列中的一个线程,而notifyAll()会唤醒所有挂起的线程.</p><p>如果换成notify()会怎么样呢?</p><p>假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。</p><p>所以除非经过深思熟虑，否则尽量使用 notifyAll()。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python: 进阶用法</title>
      <link href="/2021/12/09/python-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/"/>
      <url>/2021/12/09/python-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="被忽略的内部方法"><a href="#被忽略的内部方法" class="headerlink" title="被忽略的内部方法"></a>被忽略的内部方法</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p>python给人的感觉有时候像一个linux命令,我们都知道linux有man page查看命令的用法,当我们import了一个包的时候,如果想知道它有哪些写法,或者想知道自己调的方法的描述,试着用用help吧.</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>python 为了尽可能的精简代码,相比其他代码省去了对象类型描述,这种弱化对象类型的做法在编程时候带来诸多便利的同时,也给Debug带来了更多困难,有时候甚至不知道调用函数返回的是什么,这对程序员来说是很危险的,错误的类型判断,很容易做出驴唇不对马嘴的操作,在jupyter等诸多交互式编程工具盛行的时代,type(anything) 看一下是什么类型再做下一步操作吧.</p><h2 id="PEP8-python编程规范"><a href="#PEP8-python编程规范" class="headerlink" title="PEP8 python编程规范"></a>PEP8 python编程规范</h2><p>想要代码水平有所提高,总免不了code review,这个环节除了考察逻辑漏洞,我觉得最关键的一点就是代码的可读性,一个可读性高的代码,更加易读易维护.PEP8包含了大量的如何编写python代码的细节.下面列举几个重要的规则:</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>在python中,空格是一个很重要的语法,空格的普适性建议:</p><ul><li>使用空格而不是用tab键来缩进.</li><li>使用4个空格作每一层的缩进</li><li>每行代码应该尽量少于79个:字符</li><li>在一个文件中,函数和类之间用两个空行隔开</li><li>方法与方法之间用一个空行隔开</li><li>列表索引,函数调用或关键字参数赋值两侧不要用空格</li><li>变量赋值的等号两边有且仅有一个空格</li></ul><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>推荐(if a is not b),不推荐(if not a is b)</li><li>推荐(if not somelist),不推荐(if len(somelist) == 0)</li><li>if,while,for, try,except等分支关键字请不要放在一行</li><li>总是把import写在文件最顶部</li></ul><h2 id="args和-kwargs"><a href="#args和-kwargs" class="headerlink" title="*args和**kwargs"></a>*args和**kwargs</h2><p>python的可变参数,比起java要讨喜的多,一个可变参数的方法,解决了java的n多方法重写,有这么好用的特性,不得安排起来吗?</p><p>使用场景是<code>预先不知道调用者会传入多少参数的时候</code></p><p>注: *args 和 **kwargs 并不是唯一写法,如果你喜欢,可以写成 *vars ,  以及    **vars</p><h3 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h3><p>*args用来接收一个有序的参数列表,在方法内部可以把args当做list来调用</p><p>比如,内置的sum只能求可迭代列表的和,我们想要自己定义一个求和方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span>(<span class="params">*args</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        res+=n</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>定义了上述方法,我们就可以用<code>my_sum(1,4,5,6,7,8)</code>来求得不确定个数的和了.</p><h3 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>**kwargs</h3><p>*kwargs用来接收一个参数键值对,在方法内部可以把kwargs当做dict来调用:</p><p>比如我们要写一个方法保存不确定的键值对到非关系型数据库.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_kv</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        save_single_record(k,v)</span><br></pre></td></tr></table></figure><p>save_kv可以用两种方式来调用:</p><ul><li><p>save_kv(name=’zhangsan’,age=18)</p></li><li><p>params = {‘name’:’zhangsan’,’age’:18}</p><p>  save_kv(**params)</p></li></ul><h2 id="调试Debugging"><a href="#调试Debugging" class="headerlink" title="调试Debugging"></a>调试Debugging</h2><p>不同于Java这种长在IDE上面的编程语言(不是说没有IDE就写不了Java,我是说大部分情况下写Java都在IDE中),python代码由于轻量,linux内置,很多时候没有IDE的debug环境,很多时候vim就在服务器上面写完了python,那如果出问题了如何debug呢?</p><p>答案是pdb(python debug),官网链接附上:</p><p><a href="https://docs.python.org/2/library/pdb.html">python2 debug</a></p><p><a href="https://docs.python.org/3/library/pdb.html">python3 debug</a></p><h3 id="从命令行debug"><a href="#从命令行debug" class="headerlink" title="从命令行debug"></a>从命令行debug</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python -m pdb short_script.py</span></span><br></pre></td></tr></table></figure><p>这会触发debugger在脚本第一行指令处停止,在脚本很短的时候很有用;</p><h3 id="从脚本内部运行"><a href="#从脚本内部运行" class="headerlink" title="从脚本内部运行"></a>从脚本内部运行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_bread</span>():</span></span><br><span class="line">pdb.set_trace()</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;I don&#x27;t have time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(make_bread())</span><br></pre></td></tr></table></figure><p>pdb.set_trace()就是在这一行打了一个断点,与IDE里面的debug模式意思一样.</p><p>debugger模式怎么操作呢?</p><table><thead><tr><th>按键</th><th>操作</th></tr></thead><tbody><tr><td>c</td><td>继续执行</td></tr><tr><td>w</td><td>显示正在执行的代码的上下文信息</td></tr><tr><td>a</td><td>打印当前函数的参数列表</td></tr><tr><td>s</td><td>单步进入(IDE中的step into)</td></tr><tr><td>n</td><td>单步跳过(IDE中的step over)</td></tr></tbody></table><h2 id="生成器-Generators-和迭代器-Iterators"><a href="#生成器-Generators-和迭代器-Iterators" class="headerlink" title="生成器 Generators 和迭代器 Iterators"></a>生成器 Generators 和迭代器 Iterators</h2><h3 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象(Iterable)"></a>可迭代对象(Iterable)</h3><p>python中的任意对象,只要它定义了可以返回一个迭代器__iter__方法,或者定义了可以支持下标索引的__getitem__方法,那么它就是一个可迭代对象.</p><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><p>任意对象,只要定义了next(python2),__next__(python3)方法,它就是一个迭代器.</p><h3 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h3><p>生成器也是一种迭代器,但是你只能对其迭代一次,因为它们并没有把所有的值保存在内存中,而是在运行时生成.大多数时候生成器是以函数来实现的.然而它们并不是返回一个值,而是用yield(“生出”)一个值.</p><p>当斐波那契数列传的n的值很大的时候,就可以用生成器来写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_gen</span>(<span class="params">n</span>):</span></span><br><span class="line">    a=b=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a,b = b,a+b</span><br></pre></td></tr></table></figure><p>它跟传统方式有什么区别?</p><p>传统return写法,如果n=100000(十万),这个方法调用需要占用大量的内存,因为它在内存中开辟了一个十万大小的list,然而用yield就完全不用担心.</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>同很多编程语言一样,python也有三元运算符.</p><p>python的三元运算符有两种写法:</p><h3 id="human语言习惯法"><a href="#human语言习惯法" class="headerlink" title="human语言习惯法"></a>human语言习惯法</h3><p>为什么叫人类语言习惯法?看下面伪代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">去打球 if 不下雨 else 宅家里</span><br></pre></td></tr></table></figure><p>这,后置说法可能山东老哥们看起来倍儿熟悉吧.</p><h3 id="machine的01法"><a href="#machine的01法" class="headerlink" title="machine的01法"></a>machine的01法</h3><p>0是False,1是True,数据库里面是不是很常见,这种思想同样可以被用到三元表达式中,对于上述伪代码,就变成了下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(宅家里,去打球)[不下雨]</span><br></pre></td></tr></table></figure><p>不下雨会被计算成0或1,0对应二元组的第一个也就是三元运算否的情况,1对应二元组第二个也就是三元运算是的情况.</p><h2 id="装饰器-Decorator"><a href="#装饰器-Decorator" class="headerlink" title="装饰器 Decorator"></a>装饰器 Decorator</h2><p>相信学过spring的同学都听过AOP这么一个听起来很高大上的玩意,面向切面编程,用注解实现方法执行前后的代码,在python里面,装饰器就可以实现AOP.</p><p>要理解装饰器,首先要明确一个概念,<strong>方法也是对象,方法也可以当做方法参数</strong></p><h3 id="方法也是对象"><a href="#方法也是对象" class="headerlink" title="方法也是对象"></a>方法也是对象</h3><p>方法也是对象怎么理解?为了方便理解这个重要概念,看下面代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&#x27;zhangsan&#x27;</span></span>):</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="string">&quot;hi,&quot;</span> + name</span><br><span class="line">&gt; <span class="built_in">print</span>(hi())</span><br><span class="line"><span class="comment">#output: &#x27;hi,zhangsan&#x27;</span></span><br><span class="line"><span class="comment">#重点来了</span></span><br><span class="line">&gt; greet = hi</span><br><span class="line">&gt; <span class="built_in">print</span>(greet())</span><br><span class="line"><span class="comment">#output: &#x27;hi,zhangsan&#x27;</span></span><br><span class="line">&gt; <span class="keyword">del</span> hi</span><br><span class="line">&gt; <span class="built_in">print</span>(hi())</span><br><span class="line"><span class="comment">#NameError:Nosuch method</span></span><br><span class="line">&gt; <span class="built_in">print</span>(greet())</span><br><span class="line"><span class="comment">#output: &#x27;hi,zhangsan&#x27;</span></span><br></pre></td></tr></table></figure><p>def似乎是定义了一个对象模板,第六行就像对象赋值一样把hi赋值给了greet,由此看来方法也是对象.</p><h3 id="方法可以当做方法的参数"><a href="#方法可以当做方法的参数" class="headerlink" title="方法可以当做方法的参数"></a>方法可以当做方法的参数</h3><p>正是AOP的核心思想,在python中,方法可以接收一个方法当做参数在其内部执行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;look! this is pythonic @Before&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;and this is pythonic @After&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br></pre></td></tr></table></figure><p>上面方法参数是一个方法,返回值也是一个方法,实现了AOP般的装饰Before,After是不是在Spring中见过?</p><p>对于一个其他方法来说,就可以用注解来装饰此方法了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@myWrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is a function&#x27;</span>)</span><br></pre></td></tr></table></figure><p>自定义的myWrapper,实现了对方法的装饰,但是有一个问题,对于被装饰的方法,print(fun.__name__)打印出来的就是myWrapper,就是说我们把方法包装起来之后,只能看到包装了,那么怎么在包装起来的同时,不改变原来的name呢?</p><p>只要用functools.wraps来修改一下我们的装饰器即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;look! this is pythonic @Before&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;and this is pythonic @After&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br></pre></td></tr></table></figure><h3 id="装饰器的应用场景"><a href="#装饰器的应用场景" class="headerlink" title="装饰器的应用场景"></a>装饰器的应用场景</h3><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授权是web服务面向切面编程的一个典型使用场景,python中的Django跟flask也有大量的使用场景,这里是一个装饰器授权的demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">require</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args,**kwargs</span>)</span></span><br><span class="line"><span class="function">    <span class="title">auth</span> = <span class="title">request</span>.<span class="title">authorization</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="title">not</span> <span class="title">auth</span>:</span></span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure><h4 id="日志封装"><a href="#日志封装" class="headerlink" title="日志封装"></a>日志封装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(f.__name__ + <span class="string">&quot; was called &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> f(*args,**kwargs)</span><br><span class="line">   <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: demo was called</span></span><br></pre></td></tr></table></figure><p>是不是有点Spring boot的意思了,但是你可能会说,Spring Boot的注解是可以加参数的,<strong>python 也可以!</strong></p><p>因为@wraps也是装饰器,它接收一个参数,就像普通函数那样,记住,方法就是对象,那么解决方案就是_再!包!一!层!_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment">#不传参的时候默认往std.out里面打印</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span>(<span class="params">logfile=<span class="string">&#x27;std.out&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">logging_decorator</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">f</span>)</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">wrap_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            log_str = f.__name__ + <span class="string">&quot;was called&quot;</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(logfile,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(log_str + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrap_func</span><br><span class="line">    <span class="keyword">return</span> logging_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#往std.out里面打印myfunc1 was called</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(<span class="params">logfile=<span class="string">&#x27;demo.log&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;dosome thing&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#往demo.log里面打印myfun2 was called</span></span><br></pre></td></tr></table></figure><h2 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h2><p>在python中,每个类都有实例属性,默认情况下python会用一个字典来保存这些变量的属性名跟属性值.</p><p>这通常很有用,它允许我们子啊运行时任意设置新的属性.</p><p>然而,如果这个类拥有很多已知属性的小类来说,由于字典的可扩展性我们可以猜到,为了保证在扩展时有内存可用,通常会”预留”较大的内存,如果小类的成员数量已知.我们怎么告诉python不要使用可扩展的字典,而是使用一种固定大小的数据结构呢?</p><p>答案是__slot__</p><p>不使用__slot__的传统方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>)</span></span><br><span class="line"><span class="function">    <span class="title">self</span>.<span class="title">name</span> = <span class="title">name</span></span></span><br><span class="line"><span class="function">        <span class="title">self</span>.<span class="title">age</span> = <span class="title">age</span></span></span><br><span class="line"><span class="function">        <span class="title">self</span>.<span class="title">set_up</span>()</span></span><br></pre></td></tr></table></figure><p>使用了__slot__:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __slot__ = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">    self.set_up()</span><br></pre></td></tr></table></figure><p>第二段代码会为内存减轻负担,通过这个技巧,有些人已经看到内存占用率几乎减少了40%-50%</p><h2 id="集合框架-Collections"><a href="#集合框架-Collections" class="headerlink" title="集合框架 Collections"></a>集合框架 Collections</h2><p>尽管python的字典元组列表等数据结构已经足够灵活,但是面对一些复杂的结构化数据处理时,还是有些费力,这个时候,就要用到内置的集合框架包collections了.</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>defaultdict与dict不同,我们不需要检查key是否存在,比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">colours = (</span><br><span class="line">    (<span class="string">&#x27;Yasoob&#x27;</span>,<span class="string">&#x27;Yellow&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Ali&#x27;</span>,<span class="string">&#x27;Blue&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Arham&#x27;</span>,<span class="string">&#x27;Green&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Ali&#x27;</span>,<span class="string">&#x27;Black&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Yasoob&#x27;</span>,<span class="string">&#x27;Red&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Ahmed&#x27;</span>,<span class="string">&#x27;Silver&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">favorite_colours = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name,color <span class="keyword">in</span> colours:</span><br><span class="line">    favorite_colours[name].append(color)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(favorite_colours)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment"># defaultdict(&lt;type &#x27;list&#x27;&gt;,</span></span><br><span class="line"><span class="comment">#&#123;&#x27;Arham&#x27;: [&#x27;Green&#x27;],</span></span><br><span class="line"><span class="comment"># &#x27;Yasoob&#x27;: [&#x27;Yellow&#x27;, &#x27;Red&#x27;],</span></span><br><span class="line"><span class="comment"># &#x27;Ahmed&#x27;: [&#x27;Silver&#x27;],</span></span><br><span class="line"><span class="comment"># &#x27;Ali&#x27;: [&#x27;Blue&#x27;, &#x27;Black&#x27;]</span></span><br><span class="line"><span class="comment"># &#125;)</span></span><br></pre></td></tr></table></figure><p>或者,可以直接嵌套赋值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">tree = <span class="keyword">lambda</span>: collections.defaultdict(tree)</span><br><span class="line">some_dict = tree()</span><br><span class="line">some_dict[<span class="string">&#x27;color&#x27;</span>][<span class="string">&#x27;favorite&#x27;</span>] = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&quot;color&quot;:&#123;&#x27;favorite&#x27;:&#x27;blue&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter是一个计数器,可以针对某项数据进行计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;yellow&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line">cnts = Counter(colors)</span><br><span class="line"><span class="built_in">print</span>(cnts)</span><br><span class="line"><span class="comment"># &#123;&#x27;blue&#x27;:3,&#x27;yellow&#x27;:2,&#x27;green&#x27;:1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque是一个限制了list部分方法的双端队列,可以从头尾两端添加或删除元素,而且在创建时指定maxlen,就可以限制大小.如果超过大小,数据会从队列另一段被挤出(pop)</p><h2 id="推导式-Comprehension"><a href="#推导式-Comprehension" class="headerlink" title="推导式 Comprehension"></a>推导式 Comprehension</h2><p>推倒式在python 2和3中都有支持,是python独有且好用的特性,有了它,甚至不用知道map,filter,因为在python3里面 map的结果是一个map对象,filter的结果是一个filter对象,这些用推导式就可以搞定.</p><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#map推导式,对nums中的每个元素平方</span></span><br><span class="line">nums2 = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line"><span class="comment"># 如果用map,需要这么写 num2 = list(map(lambda x:x**2, nums))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filter,筛选偶数</span></span><br><span class="line">num3 = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">##如果用filter,需要写 num3 = list(filter(lambda x: x%2==0,nums) )</span></span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mcase = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">15</span>&#125;</span><br><span class="line"><span class="comment"># kv互换</span></span><br><span class="line">mcase_reverse = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> mcase.items()&#125;</span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>集合推导式跟列表推导式相同,只是用的是大括号{},比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">nums2 = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(4):死锁</title>
      <link href="/2021/12/07/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
      <url>/2021/12/07/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="转账场景"><a href="#转账场景" class="headerlink" title="转账场景"></a>转账场景</h2><p>假设转账场景发生在古代,没有信息化,账户就是一个账本,所有的账本都在统一的账本库里,一个转账操作需要转入者跟转出者两本账本才能完成.由于来银行转账的用户多,银行雇佣了多个柜员(每个柜员就是一个线程).一笔转账需求发生的时候,柜员则需要取出两本账本,柜员取账本可能遇到下列三种情况:</p><ul><li>账本库上正好有转入账本和转出账本,同时拿走;</li><li>账本库只有其中一本,那就先拿这一本,等待其他柜员把另一本送回来;</li><li>两本都被其他柜员拿走了,这个柜员等着这两个账本都被送回来;</li></ul><p>上面场景用Java程序模拟怎么实现呢? 用两把锁就可以实现,转入账本一把,转出账本一把:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="comment">//拿到本账户的账本</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//拿到目标账户的账本</span></span><br><span class="line">            <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.balance &gt;= amount)&#123;</span><br><span class="line">                <span class="keyword">this</span>.balance -= amount;</span><br><span class="line">                target.balance += amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述场景的问题看似被完美解决,假如账户A找柜员做业务: 给账户B转100块,账户B在同时也找柜员做另一笔业务: 给账户A转100块. 就会出现两个柜员各拿一本账本,各自等待对方送回另一本账本,就导致了典型死锁问题.</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁指的是: 一组互相竞争资源的线程因互相等待,导致”永久”阻塞的问题.</p><p>下面看一下Coffman总结的死锁的发生需要下列四个条件同时满足:</p><ul><li>互斥, 共享资源X和Y同时只能被一个线程持有;</li><li>占有且等待, 线程已经持有某个共享资源,在等待另一个共享资源的时候不释放自己持有的资源;</li><li>不可抢占,其他线程不能强行抢占线程T1的资源</li><li>循环等待, 线程T1等待线程T2持有的资源,线程T2等待线程T1持有的资源就是循环等待.</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>破坏上述四个规则之一就可以避免死锁.</p><p>互斥无法被破坏,因为使用锁的前提就是要提供互斥方案,所以我们从另外三个条件逐一想办法:</p><h3 id="破坏占有且等待"><a href="#破坏占有且等待" class="headerlink" title="破坏占有且等待"></a>破坏占有且等待</h3><p>在上述转账场景中,如果不让单独持有一个账本,或者没拿到就不等待的话.也就是说增加账本管理员角色,每个柜员告诉管理员自己需要哪两本账本,然后账本管理员检查账本库是否这两本账本都可用,然后一次性发放,就不存在占有且等待了,写成java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; hasBeenAllocated = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//用来记录哪些账本已经被拿走了</span></span><br><span class="line">    <span class="comment">//同时申请两个资源的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(T from,T to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasBeenAllocated.contains(from) ||hasBeenAllocated.contains(to))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasBeenAllocated.add(from);</span><br><span class="line">        hasBeenAllocated.add(to);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(T from, T to)</span></span>&#123;</span><br><span class="line">        hasBeenAllocated.remove(from);</span><br><span class="line">        hasBeenAllocated.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    Allocator&lt;Account&gt; actr = <span class="keyword">new</span> Allocator();</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target,<span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>,target));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.balance &gt;= amt)&#123;</span><br><span class="line">                <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">             actr.free(<span class="keyword">this</span>,target);   </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件看上去很简单,核心是线程主动释放资源,这一点synchronized做不到,因为在申请其他资源的时候如果申请不到,synchronized会让当前线程阻塞,进入阻塞状态下的线程什么都做不了,更别谈释放资源了.</p><p>所以在语言层面上,java无法解决这个问题,不过在JUC SDK里面,Lock还是能轻松解决这个问题的,后续讲Lock再展开.</p><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>破坏循环条件,只要实现:如果t1跟t2都需要共享资源X和Y,保证永远要先拿到X再拿到Y就可以了,对应到上述例子就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> balance;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        Account left = <span class="keyword">this</span>;</span><br><span class="line">        Account right = target;</span><br><span class="line">        <span class="keyword">if</span>(target.id&gt;<span class="keyword">this</span>.id)&#123;</span><br><span class="line">           left = target;</span><br><span class="line">           right = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.balance&gt;= amount)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.balance -= amount;</span><br><span class="line">                    target.balance += amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(3): synchronized关键字</title>
      <link href="/2021/12/06/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81/"/>
      <url>/2021/12/06/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>先说结论: synchronized关键字是java 提供互斥方案,保证<strong>同一时间只有一个线程操作资源</strong>,锁的<strong>同步</strong>实现.</p><p>在刚开始学习java并发编程的时候,一遇到锁的问题,第一时间想到的就是synchorized关键字,在JDK1.5之前,synchronized是一个重量级锁,</p><p>效率不尽如人意.JDK 1.6 对synchronized锁进行了升级优化,引入了偏向锁和轻量级锁，提高了获取锁和释放锁的效率。</p><h2 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h2><p>下列代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看编译成的字节码:</p><p><img src="https://s2.loli.net/2021/12/06/JYQcMadSPevAU3G.png" alt="image-20211206142112814"></p><p>可以看出来代码块同步使用monitorenter和monitorexit指令实现的.将这两条指令插入到代码块的开始与结束位置或异常处.<strong>任何对象都有一个monitor对象</strong>,当monitor被持有后,它将处于锁定状态.</p><p>同步代码块的实现是monitorenter和monitorexit指令,那同步方法呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;this is sync method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这个代码,结果如下:</p><p><img src="https://s2.loli.net/2021/12/07/jXuJzLwAIitk6OD.png" alt="image-20211207101528437"></p><p>被synchronized修饰的方法在JVM层面并没有对应的字节码指令,而是在flags里面加了一个ACC_SYNCHRONIZED访问标志,调用该方法时,检查ACC_SYNCHRONIZED是否被设置,如果设置了,则尝试获取monitor对象,获取成功才能执行该方法.</p><h2 id="java对象头的概念"><a href="#java对象头的概念" class="headerlink" title="java对象头的概念"></a>java对象头的概念</h2><p>与报文Header一样,java对象也有存放元数据的对象头,synchronized用的锁就是存放在java对象头里.</p><p>Java对象头主要包括两部分数据:</p><ul><li>Mark Word(标记字段): 存储对象的hashcode和锁信息</li><li>Class Pointer(类型指针): 指向类元数据的指针,JVM通过这个指针判断对象是哪个类的实例</li></ul><p>如果对象是数组,数组对象比普通对象多的一个字宽.还有第三部分数据即数组长度,</p><ul><li>Array Length : 数组的长度</li></ul><p>如果对象是数组类型,则用3个字宽(Word)存储对象头,如果是非数组类型,则用2个字宽.32位虚拟机中,一个字宽是4个字节,即32bit.</p><p>来看一下32位虚拟机的对象头在运行过程中的变化(涉及到锁的升级.)</p><table><thead><tr><th>锁状态</th><th>25bit(hashcode或锁信息)</th><th>4bit(对象分代年龄)</th><th>1bit(是否偏向锁)</th><th>2bit(锁标志)</th></tr></thead><tbody><tr><td>无锁</td><td>hashcode</td><td></td><td>0</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td></td><td>0</td><td>00</td></tr><tr><td>偏向锁</td><td>23bit: 线程ID, 2bit Epoch(偏向时间戳)</td><td></td><td>0</td><td>01</td></tr><tr><td>重量级锁</td><td>指向互斥锁的指针</td><td></td><td>0</td><td>10</td></tr><tr><td>GC标记</td><td>空</td><td></td><td>1</td><td>11</td></tr></tbody></table><p>64位虚拟机与32位虚拟机相似,markword大小是64位的,不同的是32位虚拟机用25bit记录hashcode和锁的信息,64位虚拟机用56位,还有一个bit用来记录cms_free(CMS垃圾回收标志).</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>31bit</th><th>1bit(cms_free)</th><th>4bit(分代年龄)</th><th>1bit(是否偏向锁)</th><th>2bit(锁标志)</th></tr></thead><tbody><tr><td>无锁</td><td>unused</td><td>hashCode</td><td></td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>ThreadID(54bit)</td><td>Epoch(2bit)</td><td></td><td></td><td>1</td><td>01</td></tr></tbody></table><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>Synchronized 内部有一个隐藏的锁升级流程，正是因为这个流程的存在，使得 Synchronized 得以发挥它的高性能特性.</p><p>其中锁升级中最重要的就是轻量级锁和偏向锁.</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>从字面上看,偏向的意思是资源在分配的时候偏向某一个竞争者的设计.Java中的偏向锁也可以这么记忆.</p><p>通常情况下对象不存在多线程竞争,而且总是有某一个线程多次获得.为了提高该线程获取锁的效率,JVM在对象头的MarkWord记录了偏向线程的ID,该ID的线程获取锁的时候不需要通过CAS操作来加锁和解锁,只要对比一下自身ID与MarkWord里面的偏向线程ID是否相等即可.</p><p>如果相等,跳过CAS,表示成功获取锁;如果失败,使用CAS竞争锁,在竞争成功后将MarkWord的ThreadID改成自身ID方便自己下次获取锁.</p><p>偏向锁在JDK6之后是默认启用的,但是它在应用程序启动几秒后延迟激活.可以使用<code>-XX:BiasedLockingStartupDelay=0</code>来关闭这个延迟,如果应用程序的资源通常都存在多线程竞争,可以配置<code>-XX:UseBiasedLocking=true</code>来关闭偏向锁,让程序默认进入轻量级锁.</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁并不是替代重量级锁的,只是在多线程竞争不激烈的时候提升程序性能用的.</p><p>轻量级锁的加锁过程是这样的: 线程尝试将对象头的锁记录复制到自己的栈帧中,官方称为Displaced Mark Word.这一步可以理解为每个线程做一次,然后各自尝试通过自旋将竞争资源的mark word修改为指向自己栈帧.</p><p>为什么要用自旋?</p><p>如果不用自旋的话,线程修改markword就只能挂起,等待修改成功的线程释放资源并唤醒,频繁切换线程状态(挂起-&gt;唤醒-&gt;挂起)会带来巨大的开销(用户态到内核态的切换开销很大).</p><p>自旋多少次合适?</p><p>JDK 1.6默认的自旋次数为10次**,意味着自旋超过10次没有获取到资源,轻量级锁就会膨胀为重量级锁.** 可以通过<code>-XX:preBlockSpin</code>调整次数,但是指定了该参数会破坏JDK1.6的自适应自旋锁策略(动态调整自旋次数). 动态自旋可以更聪明的调整synchronized的性能,所以一般不调整.</p><h2 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a>锁的膨胀</h2><p>假设不考虑jdk 1.6的自适应自旋策略,那么锁的膨胀过程应该如下图:</p><p><img src="https://s2.loli.net/2021/12/07/N2TOPSw8DCsQhKo.png" alt="锁的升级"></p><p>那么来对比一下上述几种锁的适用场景吧</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁解锁不需要额外消耗,与无锁相比仅存在纳秒级别的差别</td><td>如果线程存在竞争会有额外撤出偏向锁的消耗</td><td>适用于只有一个线程访问同步代码块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞,提高了线程响应速度</td><td>如果获取不到锁,自旋会消耗CPU资源</td><td>追求响应时间,同步块执行速度较快的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不再自旋,不消耗CPU</td><td>线程阻塞到唤醒响应时间长</td><td>追求吞吐量,同步块执行时间长</td></tr></tbody></table><h2 id="锁的消除"><a href="#锁的消除" class="headerlink" title="锁的消除"></a>锁的消除</h2><p>锁消除指的是JVM通过<strong>逃逸分析技术</strong>,判断一个资源没有被多线程竞争的可能的时候,编译成的字节码里面会把锁消除,对JVM来说就是没有锁.也就是说,消除的是”代码中误以为存在的锁”,对JVM来说可能就没有锁.</p><p>比如在单线程场景中使用StringBuffer,到字节码就会变成StringBuilder这种无锁操作.</p><h2 id="锁的粗化"><a href="#锁的粗化" class="headerlink" title="锁的粗化"></a>锁的粗化</h2><p>锁的粗化也是jvm对代码的一种编译手段,主要是优化循环中的加锁释放锁.</p><p>如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(xx)&#123;</span><br><span class="line">      <span class="comment">// do something   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被粗化成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(xx)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的膨胀机制,消除机制跟粗化机制,都是JDK在优化synchronized关键字锁做出的努力.可以说,某些情况下,Synchronized关键字的性能比JUC并发包下面的锁工具类还要好.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(2): 内存模型</title>
      <link href="/2021/12/03/Java%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/12/03/Java%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>前文说到,导致程序出现可见性Bug的源头是<strong>缓存</strong>,导致有序性Bug的源头是<strong>编译优化</strong>.那如果禁用这两项技术,让硬件性能倒退到优化前,不就解决了并发导致的Bug了吗? 但是并发就是用来提升性能的,这么一退用并发编程也变得舍本逐末了.那如果能<strong>按需禁用</strong>呢?</p><p>为了做到<strong>按需禁用缓存和编译优化</strong>,Java提供了一个很复杂的<strong>内存模型规范.<strong>本质上就是规范了JVM如何按需提供禁用编译和缓存优化的方法.具体来说,这些方法包括</strong>三个关键字( volatile, synchronized,final),七项Happens-Before规则</strong></p><p>接下来就来展开讲一下这些关键字和Happens-Before规则.</p><h2 id="三个与内存模型相关的关键字"><a href="#三个与内存模型相关的关键字" class="headerlink" title="三个与内存模型相关的关键字"></a>三个与内存模型相关的关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final的应用场景分为:</p><ul><li>final variable -&gt; 不可修改的变量</li><li>final method -&gt; 无法重写的方法</li><li>final class-&gt; 无法继承的类</li></ul><p>从上述场景来看,final都是在阻止引用被修改.<strong>让变量不可变</strong>就是final在Java内存模型中的作用,<em>虽然被final修饰的对象还是可以修改值,但从编程习惯出发,我不建议这么做,final在固定reference的同时,也在告诉维护人员,该变量也被固定了</em>.如果在遵循final修改的值唯一不变的情况下,多线程共享的时候,我们认为也是安全的.</p><p>所以final关键字对于编译器的意义就是: <strong>告诉编译器,这个变量生而不变,可劲优化.</strong></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>Java关于synchronized关键字的知识点比较多,在内存模型中不做过多讨论,可以理解成JDK提供的同步关键字,用来解决前文提及的<strong>互斥</strong>需求,以保证数据不会因为多线程而紊乱.</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile关键字不是java特产,C语言也有,它设计之初就是为了禁用CPU缓存.</p><p>例如,在声明一个变量volatile int x=0,表达的意思就是: <strong>告诉编译器,对于变量x的读写,不能使用CPU缓存,直接从内存中读写.</strong></p><p>基于这点,就有了volatile的两个重要作用:</p><ul><li>**保证内存可见性,**即一个线程对于共享变量的修改,对于其他线程来说是可见的</li><li><strong>禁用指令重排序</strong>,用来解决前文提及的编译优化带来的有序性问题</li></ul><p>那么如何用volatile实现安全的双重检验单例模式呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它是如何解决禁止编译器优化呢? 除了对单个变量禁用缓存之外, java 在 jdk 1.5版本对于volatile关键字语义进行了增强.那么它是如何增强的呢</p><p>就是Happens-Before规则中的<u>volatile变量规则.</u> 除了这条规则外,Happens-Before还有其他几条,下面一一介绍.</p><h2 id="Happens-Before的7个规则和1个特性"><a href="#Happens-Before的7个规则和1个特性" class="headerlink" title="Happens-Before的7个规则和1个特性"></a>Happens-Before的7个规则和1个特性</h2><p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>,具体体现为下面7条规则:</p><h3 id="1-程序次序规则"><a href="#1-程序次序规则" class="headerlink" title="1. 程序次序规则"></a>1. 程序次序规则</h3><p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p><h3 id="2-管程锁规则"><a href="#2-管程锁规则" class="headerlink" title="2. 管程锁规则"></a>2. 管程锁规则</h3><p>一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。</p><h3 id="3-volatile变量规则"><a href="#3-volatile变量规则" class="headerlink" title="3. volatile变量规则"></a>3. volatile变量规则</h3><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序</p><h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><p>Thread对象的start()方法先行发生于此线程的每一个动作。</p><h3 id="5-线程终止规则"><a href="#5-线程终止规则" class="headerlink" title="5. 线程终止规则"></a>5. 线程终止规则</h3><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()等待方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p><h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h3><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生</p><h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h3><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><p>除了上述的happens-before 的7个规则以外,还有一个重要特性:<strong>传递性</strong></p><p>怎么理解传递性?</p><blockquote><p> 若 A happens-before B , B happens-before C</p><p>则 A happens-before C</p></blockquote><p>很容易理解的时间先后顺序.</p><h2 id="java内存模型如何实现"><a href="#java内存模型如何实现" class="headerlink" title="java内存模型如何实现"></a>java内存模型如何实现</h2><p>主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile:</p><p>JVM内存屏障插入策略：</p><p>每个volatile写操作的前面插入一个StoreStore屏障；<br>在每个volatile写操作的后面插入一个StoreLoad屏障；<br>在每个volatile读操作的前面插入一个LoadLoad屏障；<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python: 用一行代码KO一个需求</title>
      <link href="/2021/12/03/%E7%94%A8%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81KO%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82/"/>
      <url>/2021/12/03/%E7%94%A8%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81KO%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>记录被python一行代码KO的需求：</p><h2 id="字符串-数组等长切割"><a href="#字符串-数组等长切割" class="headerlink" title="字符串/数组等长切割"></a>字符串/数组等长切割</h2><ul><li>当一行数据量过大，想要切成n行，每行长度为L?</li><li> 把列表n等分成二维列表，每个列表长度为L</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n_part_li = [ li[i:i+L] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(li),L) ]</span><br></pre></td></tr></table></figure><p>对上述代码的解释：<br>   利用python超级好用的切片，i为每次切割时的开始位置。只要用range()构建出每次切割时候的开始位置即可。</p><h2 id="满足多个条件中的任意一个条件"><a href="#满足多个条件中的任意一个条件" class="headerlink" title="满足多个条件中的任意一个条件"></a>满足多个条件中的任意一个条件</h2><ul><li>目标字符串以任一满足条件的字符串开头</li><li>检测字符串是否有合法head</li><li>python 中java stream.anyMatch()的写法</li><li>python 中scala exists 的写法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">any</span>(s.startswith(i) <span class="keyword">for</span> i <span class="keyword">in</span> allowed_starts)</span><br></pre></td></tr></table></figure><p>对上述代码的解释<br>    s是待检测字符串，allowed_starts是合理开头，any表示满足any中的任意一个条件。</p><h2 id="矩阵等大切割"><a href="#矩阵等大切割" class="headerlink" title="矩阵等大切割"></a>矩阵等大切割</h2><ul><li>列表切割的升级版</li><li>把9<em>9矩阵切成9个 3</em>3矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]*<span class="number">9</span></span><br><span class="line">sub_M = [[M[i+k][j:j+<span class="number">3</span>] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[1, 2, 3],[1, 2, 3],[1, 2, 3]],</span><br><span class="line"> [[4, 5, 6], [4, 5, 6], [4, 5, 6]],</span><br><span class="line"> [[7, 8, 9], [7, 8, 9], [7, 8, 9]],</span><br><span class="line"> [[1, 2, 3], [1, 2, 3], [1, 2, 3]],</span><br><span class="line"> [[4, 5, 6], [4, 5, 6], [4, 5, 6]],</span><br><span class="line"> [[7, 8, 9], [7, 8, 9], [7, 8, 9]],</span><br><span class="line"> [[1, 2, 3], [1, 2, 3], [1, 2, 3]],</span><br><span class="line"> [[4, 5, 6], [4, 5, 6], [4, 5, 6]],</span><br><span class="line"> [[7, 8, 9], [7, 8, 9], [7, 8, 9]]]</span><br></pre></td></tr></table></figure><h2 id="嵌套列表展平"><a href="#嵌套列表展平" class="headerlink" title="嵌套列表展平"></a>嵌套列表展平</h2><p>需要import itertools</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="built_in">list</span>(itertools.chain.from_iterable(a))</span><br></pre></td></tr></table></figure><p>更常见的是二维列表展平,这个时候可以用更常见的reduce解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">reduce(<span class="keyword">lambda</span> x,y : x + y, a)</span><br></pre></td></tr></table></figure><h2 id="获取指定日期的周一跟周日"><a href="#获取指定日期的周一跟周日" class="headerlink" title="获取指定日期的周一跟周日"></a>获取指定日期的周一跟周日</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取周一</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">date = datetime.strptime(dt,<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">monday = (date - timedelta(days=date.weekday()).strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">sunday = (date + timedalta(days=<span class="number">6</span>-date.weekday()).strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br></pre></td></tr></table></figure><p>技巧: weekday 从0到6. 周一是0,周日是6.</p><h2 id="判断一个字符串是不是回文字符"><a href="#判断一个字符串是不是回文字符" class="headerlink" title="判断一个字符串是不是回文字符"></a>判断一个字符串是不是回文字符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">all</span>(s[i] == s[-<span class="number">1</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)//<span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink(2): 定时器</title>
      <link href="/2021/12/03/Flink-2-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2021/12/03/Flink-2-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="flink定时器的使用场景"><a href="#flink定时器的使用场景" class="headerlink" title="flink定时器的使用场景"></a>flink定时器的使用场景</h2><p>时间对于整个flink系统都是非常重要的,这篇文章不讨论Flink的时间语义,接着上文快速上手的欺诈校验,我们接触到了flink的定时器.</p><p>那么,<strong>定时器可以干嘛</strong>?</p><ul><li><p>由DataStreamElement触发,可以在指定特征的DataStreamElement开启一个倒计时操作(比如在接收到一个close信号之后开始延时关闭系统,或者手动实现TTL,让某个状态在指定时间后过期.)</p></li><li><p>可以在流数据中实现周期性的动作,在flink中的应用有定时持久化状态到DB或FS.比如定时触发窗口计算.</p></li><li><p>突破Window的内存瓶颈,在flink中常见的周期性触发某种计算常见的是window,但是window在计算的时候会把周期时间内的所有element’留在’内存中,如果实时流特别大,很容易OOM.</p></li></ul><h2 id="flink定时器怎么用"><a href="#flink定时器怎么用" class="headerlink" title="flink定时器怎么用"></a>flink定时器怎么用</h2><p>类比生活场景,将定时器类比一个闹钟,闹钟抽象出来就是两步: 1. 设置触发时间 2.时间到了就响</p><p>对应到flink中同样是两步(拿ProcessingTime举例):</p><ol><li><p>设置定时器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.timerService.registerProcessingTiemTimer(ctx.timerService().currentProcessingTime() + DURATION)</span><br></pre></td></tr></table></figure></li><li><p>时间到了开始响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//TODO 触发之后的动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><h3 id="手动TTL"><a href="#手动TTL" class="headerlink" title="手动TTL"></a>手动TTL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeHint;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeInformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLWithTimer</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ValueState&lt;Boolean&gt; hasTimer;</span><br><span class="line">    <span class="keyword">private</span> ValueState&lt;I&gt; timedValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIVE_MINUTE = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, KeyedProcessFunction&lt;K, I, O&gt;.OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        timedValue.clear(); <span class="comment">//过期删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        hasTimer = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;timer&quot;</span>, Types.BOOLEAN));</span><br><span class="line">        timedValue = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;I&gt;(<span class="string">&quot;timer&quot;</span>, TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;I&gt;() &#123;</span><br><span class="line">        &#125;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, KeyedProcessFunction&lt;K, I, O&gt;.Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//用%1000==0 模仿特定的判断条件</span></span><br><span class="line">        <span class="keyword">if</span> (value.hashCode() % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; hasTimer.value() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timedValue.update(value);</span><br><span class="line">            hasTimer.update(<span class="keyword">true</span>);</span><br><span class="line">            ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + FIVE_MINUTE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="周期调用"><a href="#周期调用" class="headerlink" title="周期调用"></a>周期调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicalCall</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ValueState&lt;Boolean&gt; hasTimer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIVE_MINUTE = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, KeyedProcessFunction&lt;K, I, O&gt;.OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        invokeFunction();</span><br><span class="line">        <span class="comment">//触发后注册下一个触发器</span></span><br><span class="line">        ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + FIVE_MINUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        hasTimer = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;timer&quot;</span>, Types.BOOLEAN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, KeyedProcessFunction&lt;K, I, O&gt;.Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasTimer.value() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hasTimer.update(<span class="keyword">true</span>);</span><br><span class="line">            ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + FIVE_MINUTE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 到点触发的动作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink(-1): 踩坑记录</title>
      <link href="/2021/12/03/Flink-1-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/12/03/Flink-1-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Static-Methods-in-interface-require-target-jvm-1-8"><a href="#1-Static-Methods-in-interface-require-target-jvm-1-8" class="headerlink" title="1. Static Methods in interface require -target:jvm-1.8"></a>1. Static Methods in interface require -target:jvm-1.8</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>gradle项目+scala 2.11+java8+flink 1.12</p><p>出错代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafkaSource.assignTimestampsAndWatermarks(<span class="type">WatermarkStrategy</span></span><br><span class="line">      .forBoundedOutOfOrderness[<span class="type">JSONObject</span>](<span class="type">Duration</span>.ofSeconds(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>报错信息：==Static Methods in interface require -target:jvm-1.8==</p><p>从报错看是scala尝试调用Java接口中的静态方法报的错。但是idea配置中编译打包都用的jdk1.8</p><p>修改以下IDEA配置无效：</p><p><img src="https://i.loli.net/2021/09/16/5hdFoyGlBqTAsOr.png" alt="image-20210916161926056"></p><p>于是思考换一个突破口，在build.gradle文件添加以下配置,问题解决。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project.tasks.compileScala.scalaCompileOptions.additionalParameters = [<span class="string">&quot;-target:jvm-1.8&quot;</span>]</span><br><span class="line">project.tasks.compileTestScala.scalaCompileOptions.additionalParameters = [<span class="string">&quot;-target:jvm-1.8&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="2-comparing-values-of-types-Long-and-Null-using-’-will-always-yield-false"><a href="#2-comparing-values-of-types-Long-and-Null-using-’-will-always-yield-false" class="headerlink" title="2.  comparing values of types Long and Null using `==’ will always yield false"></a>2.  comparing values of types Long and Null using `==’ will always yield false</h3><p>说明: Scala Flink ValueState初始化</p><p>flink算子中使用到状态的时候,需要对状态进行初始化,官网给出的写法如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(status.value() == <span class="literal">null</span>) status.update(intialValue)</span><br></pre></td></tr></table></figure><p>这个时候IDEA会报出标题所示的警告.</p><p>把status.value() 改成status警告消失但是逻辑会有bug,因为status在open函数中会被初始化,不可能为null,所以永远不会被update(initialValue).</p><p>解决方案就是无视这个Warning. 强迫症的噩梦!</p>]]></content>
      
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink(1):快速上手,欺诈校验</title>
      <link href="/2021/12/03/Flink-1-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%AC%BA%E8%AF%88%E6%A0%A1%E9%AA%8C/"/>
      <url>/2021/12/03/Flink-1-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%AC%BA%E8%AF%88%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Flink-欺诈校验-V1"><a href="#Flink-欺诈校验-V1" class="headerlink" title="Flink 欺诈校验 V1"></a>Flink 欺诈校验 V1</h1><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">-DarchetypeGroupId=org.apache.flink \</span><br><span class="line">-DarchetypeArtifactId=flink-walkthrough-datastream-java \</span><br><span class="line">-DarchetypeVersion=1.11.0 \</span><br><span class="line">-DgroupId=frauddetection  \</span><br><span class="line">-DartifactId=frauddetection \</span><br><span class="line">-Dversion=0.1 \</span><br><span class="line">-Dpackage=spendreport \</span><br><span class="line">-DinteractiveMode=false \</span><br></pre></td></tr></table></figure><h2 id="Pom文件"><a href="#Pom文件" class="headerlink" title="Pom文件"></a>Pom文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment">or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment">distributed with this work for additional information</span></span><br><span class="line"><span class="comment">regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment">to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment">&quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>frauddetection<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>frauddetection<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Flink Walkthrough DataStream Java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://flink.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target.java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target.java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;target.java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;target.java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>apache.snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache Development Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.apache.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-walkthrough-common_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- This dependency is provided, because it should not be packaged into the JAR file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add connector dependencies here. They must be in the default scope (compile). --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;flink-connector-kafka_$&#123;scala.binary.version&#125;&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add logging framework, to produce console output when running in the IDE. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- These dependencies are excluded from the application JAR by default. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Java Compiler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;target.java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;target.java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- We use the maven-shade plugin to create a fat jar that contains all necessary dependencies. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Change the value of &lt;mainClass&gt;...&lt;/mainClass&gt; if your program entry point changes. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Run shade goal on package phase --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.flink:force-shading<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>com.google.code.findbugs:jsr305<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.slf4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.logging.log4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Do not copy the signatures in the META-INF folder.</span></span><br><span class="line"><span class="comment">                                    Otherwise, this might cause SecurityExceptions when using the JAR. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>spendreport.FraudDetectionJob<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- This improves the out-of-the-box experience in Eclipse by resolving some warnings. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.m2e<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lifecycle-mapping<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lifecycleMappingMetadata</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginExecutions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginExecution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginExecutionFilter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">versionRange</span>&gt;</span>[3.0.0,)<span class="tag">&lt;/<span class="name">versionRange</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginExecutionFilter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ignore</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginExecution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginExecution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginExecutionFilter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">versionRange</span>&gt;</span>[3.1,)<span class="tag">&lt;/<span class="name">versionRange</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginExecutionFilter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ignore</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginExecution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginExecutions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">lifecycleMappingMetadata</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>==程序是如何加载的==</p><p><code>FraudDetectionJob入口类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spendreport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.sink.AlertSink;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Alert;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.source.TransactionSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skeleton code for the datastream walkthrough</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FraudDetectionJob</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建输入流,从自定义的Transaction读入</span></span><br><span class="line">DataStream&lt;Transaction&gt; transactions = env</span><br><span class="line">.addSource(<span class="keyword">new</span> TransactionSource())</span><br><span class="line">.name(<span class="string">&quot;transactions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理算子</span></span><br><span class="line">DataStream&lt;Alert&gt; alerts = transactions</span><br><span class="line">.keyBy(Transaction::getAccountId) <span class="comment">//通过id分组,相同id的流会被分配到同一个slot上</span></span><br><span class="line">.process(<span class="keyword">new</span> FraudDetector()) <span class="comment">//对每个分组进行欺诈校验</span></span><br><span class="line">.name(<span class="string">&quot;fraud-detector&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">alerts</span><br><span class="line">.addSink(<span class="keyword">new</span> AlertSink())</span><br><span class="line">.name(<span class="string">&quot;send-alerts&quot;</span>);</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">&quot;Fraud Detection&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==数据源==</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.flink.walkthrough.common.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Public;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.FromIteratorFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A stream of transactions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSource</span> <span class="keyword">extends</span> <span class="title">FromIteratorFunction</span>&lt;<span class="title">Transaction</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">new</span> RateLimitedIterator&lt;&gt;(TransactionIterator.unbounded())); <span class="comment">// 限速流来源于TransactionIterator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部类限速迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitedIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;T&gt; inner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法私有,只能在TransactionSource类中才能被实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RateLimitedIterator</span><span class="params">(Iterator&lt;T&gt; inner)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.inner = inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> inner.hasNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写FromIteratorFunction方法的next方法来不断生成数据流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inner.next(); <span class="comment">//无界流从inner data中循环生成Transaction对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>==封装起来的数据流迭代器==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.flink.walkthrough.common.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An iterator of transaction events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Transaction</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Timestamp INITIAL_TIMESTAMP = Timestamp.valueOf(<span class="string">&quot;2019-01-01 00:00:00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIX_MINUTES = <span class="number">6</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> bounded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> TransactionIterator <span class="title">bounded</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TransactionIterator(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> TransactionIterator <span class="title">unbounded</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TransactionIterator(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TransactionIterator</span><span class="params">(<span class="keyword">boolean</span> bounded)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bounded = bounded;</span><br><span class="line"><span class="keyword">this</span>.timestamp = INITIAL_TIMESTAMP.getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; data.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bounded) &#123; <span class="comment">//如果是unbounded,当index到data.size()时从头再次重新生成</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Transaction transaction = data.get(index++);</span><br><span class="line">transaction.setTimestamp(timestamp);</span><br><span class="line">timestamp += SIX_MINUTES;</span><br><span class="line"><span class="keyword">return</span> transaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//真正进入flink的数据源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Transaction&gt; data = Arrays.asList(</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">188.23</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">374.79</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">112.15</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">478.75</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">208.85</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">379.64</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">351.44</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">320.75</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">259.42</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">273.44</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">267.25</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">397.15</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">0.219</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">231.94</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">384.73</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">419.62</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">412.91</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">0.77</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">22.10</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">377.54</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">375.44</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">230.18</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">0.80</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">350.89</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">127.55</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">483.91</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">228.22</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">871.15</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">64.19</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">79.43</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">56.12</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">256.48</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">148.16</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">199.95</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">252.37</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">274.73</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">473.54</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">119.92</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">323.59</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">353.16</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">211.90</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">280.93</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">347.89</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">459.86</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">82.31</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">1</span>, <span class="number">0L</span>, <span class="number">373.26</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">2</span>, <span class="number">0L</span>, <span class="number">479.83</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">3</span>, <span class="number">0L</span>, <span class="number">454.25</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">4</span>, <span class="number">0L</span>, <span class="number">83.64</span>),</span><br><span class="line"><span class="keyword">new</span> Transaction(<span class="number">5</span>, <span class="number">0L</span>, <span class="number">292.44</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>欺诈校验规则(同一个用户上一个小于1.0下一个大于500的订单,会被检测出来):</p><p>​        最直观的思路是维持一个flag,检测每笔订单的金额,订单小于1时将flag置为true,否则置为false,当检测到大于500的订单并且flag为true的时候,该笔订单即是欺诈订单,但是有如下问题:</p><ol><li><p>订单会被分发到分布式系统的不同slot上,如果A用户有一笔小于1的订单,紧接着B用户买了一笔500以上的订单,会被认为B用户的这笔订单异常,显然不符合检查逻辑</p></li><li><p>为了维护每个用户的flag,可以尝试维护一个id-&gt;flag的映射Map,通过内存中的Map再使用第1步中的逻辑判断欺诈订单,但是常规的类成员变 量是无法做到容错处理的，当任务失败重启后，之前的状态信息将会丢失。 这样的话，如 果程序曾出现过失败重启的情况，将会漏掉一些欺诈报警。</p></li><li><p>为了应对前面的问题,Flink提供了一套支持容错状态的原语,使用最基本的原语<code>ValueState</code>,<code>ValueState</code> 是一种 <code>keyed state</code>,只能在KeyBy操作之后使用;</p><p>ValueState是一个包装类，类似于 Java 标准库里边<br> 的 AtomicReference 和 AtomicLong。 它提供了三个用于交互的方法。update 用于更新 状态，value 用于获取状态值，还有 clear 用于清空状态。 如果一个 key 还没有状态， 例如当程序刚启动或者调用过 ValueState#clear 方法时，ValueState#value 将会返 回 null。 如果需要更新状态，需要调用 ValueState#update 方法，直接更改 ValueState#value 的返回值可能不会被系统识别。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spendreport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Alert;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skeleton code for implementing a fraud detector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FraudDetector</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Long</span>, <span class="title">Transaction</span>, <span class="title">Alert</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> SMALL_AMOUNT = <span class="number">1.00</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> LARGE_AMOUNT = <span class="number">500.00</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_MINUTE = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Boolean&gt; flagState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用open完成使用前的注册,相当于初始化一个Boolean的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ValueStateDescriptor&lt;Boolean&gt; flagDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;flag&quot;</span>, Types.BOOLEAN);</span><br><span class="line">flagState = getRuntimeContext().getState(flagDescriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Transaction transaction,</span></span></span><br><span class="line"><span class="params"><span class="function">Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">Collector&lt;Alert&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Boolean lastTransactionWasSmall = flagState.value();</span><br><span class="line"><span class="keyword">if</span>(lastTransactionWasSmall!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(transaction.getAmount()&gt;LARGE_AMOUNT)&#123;</span><br><span class="line">        <span class="comment">//只有在lastTransactionWasSmall 并且本订单金额大于500时新建Alert</span></span><br><span class="line">Alert alert = <span class="keyword">new</span> Alert();</span><br><span class="line">alert.setId(transaction.getAccountId());</span><br><span class="line">collector.collect(alert);<span class="comment">//只有被collector收集的alert才会流到下一步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clean state</span></span><br><span class="line">flagState.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(transaction.getAmount()&lt;SMALL_AMOUNT)&#123;</span><br><span class="line"><span class="comment">//本金额订单小与1,将flag置为True</span></span><br><span class="line">flagState.update(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>==数据源Keyby id==</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>188.23</td><td>374.79</td><td>112.15</td><td>478.75</td><td>208.85</td></tr><tr><td>379.64</td><td>351.44</td><td>320.75</td><td>259.42</td><td>273.44</td></tr><tr><td>267.25</td><td>397.15</td><td>0.219</td><td>231.94</td><td>384.73</td></tr><tr><td>419.62</td><td>412.91</td><td>0.77</td><td>22.10</td><td>377.54</td></tr><tr><td>375.44</td><td>230.18</td><td>0.80</td><td>350.89</td><td>127.55</td></tr><tr><td>483.91</td><td>228.22</td><td>871.15</td><td>64.19</td><td>79.43</td></tr><tr><td>56.12</td><td>256.48</td><td>148.16</td><td>199.95</td><td>252.37</td></tr><tr><td>274.73</td><td>473.54</td><td>119.92</td><td>323.59</td><td>353.16</td></tr><tr><td>211.90</td><td>280.93</td><td>347.89</td><td>459.86</td><td>82.31</td></tr><tr><td>373.26</td><td>479.83</td><td>454.25</td><td>83.64</td><td>292.44</td></tr></tbody></table></li></ul><p>将案例中的数据源按照id keyby之后,再进行欺诈校验,欺诈校验认为小于1.0的订单之后下一单超过500的用户id会被校验出来(3号用户第5到第6笔订单不符合校验规则);</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ol><li><p>构建的源码无法直接运行</p><blockquote><p>错误: 无法初始化主类 spendreport.FraudDetectionJob<br>原因: java.lang.NoClassDefFoundError: org/apache/flink/streaming/api/functions/source/SourceFunction</p></blockquote></li></ol><p>修改方式:</p><p>![image-20210119141926337](/Users/dinl/Library/Application Support/typora-user-images/image-20210119141926337.png)</p><h1 id="Flink-欺诈校验V2-状态-时间-❤"><a href="#Flink-欺诈校验V2-状态-时间-❤" class="headerlink" title="Flink 欺诈校验V2: 状态 + 时间=❤"></a>Flink 欺诈校验V2: 状态 + 时间=❤</h1><p>骗子们在小额交易后不会等很久就进行大额消费，这样可以降低小额测试交易被发现的几率.假设你为欺诈检测器设置了一分钟的超时，对于上边的例子，用户3的大额消费订单只有在小额订单完成的一分钟内紧跟大额订单才算是欺诈校验.</p><p>就需要对上述程序做如下修改:</p><pre><code>             * 当标记状态被设置为 true 时，设置一个在当前时间一分钟后触发的定时器。             * 当定时器被触发时，重置标记状态。             * 当标记状态被重置时，删除定时器。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spendreport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Alert;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.walkthrough.common.entity.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skeleton code for implementing a fraud detector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FraudDetector</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Long</span>, <span class="title">Transaction</span>, <span class="title">Alert</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> SMALL_AMOUNT = <span class="number">1.00</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> LARGE_AMOUNT = <span class="number">500.00</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_MINUTE = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Boolean&gt; flagState;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Long&gt; timeSate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span></span>&#123;</span><br><span class="line">ValueStateDescriptor&lt;Boolean&gt; flagDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;flag&quot;</span>, Types.BOOLEAN);</span><br><span class="line">flagState = getRuntimeContext().getState(flagDescriptor);</span><br><span class="line"></span><br><span class="line">ValueStateDescriptor&lt;Long&gt; timeDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;timer-state&quot;</span>,Types.LONG);</span><br><span class="line">timeSate = getRuntimeContext().getState(timeDescriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;Alert&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当定时器被触发时，重置标记状态。</span></span><br><span class="line">timeSate.clear();</span><br><span class="line">flagState.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Transaction transaction,</span></span></span><br><span class="line"><span class="params"><span class="function">Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">Collector&lt;Alert&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Boolean lastTransactionWasSmall = flagState.value();</span><br><span class="line"><span class="keyword">if</span>(lastTransactionWasSmall!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(transaction.getAmount()&gt;LARGE_AMOUNT)&#123;</span><br><span class="line">Alert alert = <span class="keyword">new</span> Alert();</span><br><span class="line">alert.setId(transaction.getAccountId());</span><br><span class="line"></span><br><span class="line">collector.collect(alert);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clean state 当标记状态被重置时，删除定时器。</span></span><br><span class="line">cleanUp(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(transaction.getAmount()&lt;SMALL_AMOUNT)&#123;</span><br><span class="line"><span class="comment">//set state to True</span></span><br><span class="line">flagState.update(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">long</span> timer = context.timerService().currentProcessingTime() + ONE_MINUTE;</span><br><span class="line">context.timerService().registerEventTimeTimer(timer); <span class="comment">// 一分钟后调用onTimer,设置一分钟后的触发器</span></span><br><span class="line">timeSate.update(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">(Context ctx)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Long timer = timeSate.value();</span><br><span class="line">ctx.timerService().deleteProcessingTimeTimer(timer);<span class="comment">//删除定时器,防止定时到的时候误删状态</span></span><br><span class="line"><span class="comment">//clean up all state</span></span><br><span class="line">timeSate.clear();</span><br><span class="line">flagState.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(1): 基本认知</title>
      <link href="/2021/12/01/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/12/01/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-并发编程"><a href="#1-并发编程" class="headerlink" title="1. 并发编程"></a>1. 并发编程</h2><p>并发编程可以抽象成项目管理的三个核心问题:<strong>分工、同步和互斥</strong></p><h3 id="1-1-分工"><a href="#1-1-分工" class="headerlink" title="1.1 分工"></a>1.1 分工</h3><p>指的是对任务进行拆解,给每个线程分配合适的任务,Java SDK并发包里的Executor,Fork/Join,Future本质上都是一种分工方法.除此之外,并发编程还总结出一些与分工相关的设计模式,例如<strong>生产者-消费者,Thread-Per-Message,Work-Thread</strong></p><h3 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h3><p>同步指的是各司其职的线程如何配合完成一件事.专业术语可能叫任务之间的依赖,对应到项目管理里就是统筹,开会沟通,通知其他组成员(线程)自己的进度.Java SDK并发包里的Excutor,Fork/Join,Future同样也是来解决同步问题的.比如Future可以发起一个异步调用,当主线程通过get()方法取结果时,主线程就会等待异步执行的返回结果.除此之外,Java SD还有CountDownLatch,CyclicBarrier,Phaser,Exchanger也是用来解决线程协作问题的.</p><h3 id="1-3-互斥"><a href="#1-3-互斥" class="headerlink" title="1.3 互斥"></a>1.3 互斥</h3><p>互斥,又称”<strong>线程安全</strong>“</p><p><strong>互斥指的是同一时刻,只允许一个线程访问共享变量</strong></p><p>实现互斥的核心技术就是锁,Java语言里的Synchronized,SDK里面的各种Lock都能解决互斥问题,虽说锁解决了安全问题,也带来了性能问题.所以在指定的场景下选择合适的锁,就是学好互斥问题的关键.</p><p><img src="https://static001.geekbang.org/resource/image/11/65/11e0c64618c04edba52619f41aaa3565.png" alt="img"></p><h2 id="2-并发编程的Bug之源"><a href="#2-并发编程的Bug之源" class="headerlink" title="2. 并发编程的Bug之源"></a>2. 并发编程的Bug之源</h2><p>为什么会有Bug?</p><p>计算机设备发展的核心矛盾:<strong>CPU/内存/IO设备三者之间的速度差异</strong>,</p><p>速度 CPU &gt;&gt; 内存 &gt;&gt;&gt; IO设备.</p><p>为了平衡三者之间的速度差异,计算机体系结构,操作系统,编译程序都做出来贡献,主要体现为:</p><ol><li>CPU增加了缓存,以均衡与内存的速度差异</li><li>操作系统增加了进程,线程,以及分时复用CPU,进而均衡CPU与IO设备的速度差异</li><li>编译程序优化指令执行次序,使得缓存能够得到更加合理的利用.</li></ol><h3 id="2-1-缓存导致的可见性问题"><a href="#2-1-缓存导致的可见性问题" class="headerlink" title="2.1 缓存导致的可见性问题"></a>2.1 缓存导致的可见性问题</h3><p>一个线程对共享变量的修改对另一个线程是可见的,称为 <strong>可见性</strong>,因为多核时代每个CPU都有自己的缓存,不同CPU修改各自的缓存对于其他CPU是不可见的,就导致了可见性问题,这属于硬件程序员给软件程序员挖的坑.</p><p>例如:</p><p><img src="https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png" alt="img"></p><h3 id="2-2-线程切换带来的原子性问题"><a href="#2-2-线程切换带来的原子性问题" class="headerlink" title="2.2 线程切换带来的原子性问题"></a>2.2 线程切换带来的原子性问题</h3><p>单核时代,操作系统通过切换进程让每个进程各执行50ms(时间片),来完成”一边听歌,一边写BUG”需求,但是进程切换需要切换内存映射地址.</p><p>也就是说进程切换的代价很大,好在随着硬件提升,现代计算机更倾向于同一进程的线程切换,代价更小更轻量.但是 <strong>进程切换,也是诡异BUG的源头之一</strong></p><p>比如当两个线程同时执行count++操作的时候,就很有可能因为线程切换,导致不可预见的Bug.</p><p><img src="https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png" alt="img"></p><p>预期结果为2,因为线程切换结果为1.</p><h3 id="2-3-编译优化带来的有序性问题"><a href="#2-3-编译优化带来的有序性问题" class="headerlink" title="2.3 编译优化带来的有序性问题"></a>2.3 编译优化带来的有序性问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型问题是双重检查的单例对象创建,假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>new 对象的时候我们想象中的是这样:</p><ol><li>分配一块内存地址M</li><li>在内存地址上新建Singleton对象</li><li>把内存M赋值给instance变量</li></ol><p>编译优化之后可能是这样</p><ol><li>分配一块内存地址M</li><li>把内存M赋值给instance变量</li><li>在内存地址上新建Singleton对象</li></ol><p><img src="https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png" alt="img"></p><p>如果在实际过程中的第2步发生线程切换,裂开! NullPointeException.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
